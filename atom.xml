<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SecNotes</title>
  
  <subtitle>山河远阔 清风徐来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://comosk.github.io/"/>
  <updated>2020-03-03T14:34:47.098Z</updated>
  <id>https://comosk.github.io/</id>
  
  <author>
    <name>л</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移动安全测渗透测试——手势密码抗攻击测试</title>
    <link href="https://comosk.github.io/2020/03/03/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E6%B5%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%89%8B%E5%8A%BF%E5%AF%86%E7%A0%81%E6%8A%97%E6%94%BB%E5%87%BB%E6%B5%8B%E8%AF%95/"/>
    <id>https://comosk.github.io/2020/03/03/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E6%B5%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E6%89%8B%E5%8A%BF%E5%AF%86%E7%A0%81%E6%8A%97%E6%94%BB%E5%87%BB%E6%B5%8B%E8%AF%95/</id>
    <published>2020-03-03T14:31:46.000Z</published>
    <updated>2020-03-03T14:34:47.098Z</updated>
    
    <content type="html"><![CDATA[<p>验证是否可以通过插件绕过手势密码的验证页面</p><h3 id="0x01-测试方法"><a href="#0x01-测试方法" class="headerlink" title="0x01. 测试方法"></a>0x01. 测试方法</h3><ol><li>现在安装Xposed框架及SwipeBack插件，前文有教程</li><li>启用客户端并进入手势密码输入页</li><li>启动SwipeBack插件，观察是否可以通过滑动关闭手势密码输入页的方式进入登陆后的页面。</li></ol><p><a href="https://repo.xposed.info/module/info.papdt.swipeback" target="_blank" rel="noopener">SwipeBack插件下载地址</a></p><h3 id="0x02-威胁等级"><a href="#0x02-威胁等级" class="headerlink" title="0x02. 威胁等级"></a>0x02. 威胁等级</h3><p> 若客户端采用附着的方式将手势密码放置于登陆后的界面上时，如果无法抵抗 SwipeBack 插件的滑动攻击则高风险，如果可以抵抗则无风险。 </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;验证是否可以通过插件绕过手势密码的验证页面&lt;/p&gt;
&lt;h3 id=&quot;0x01-测试方法&quot;&gt;&lt;a href=&quot;#0x01-测试方法&quot; class=&quot;headerlink&quot; title=&quot;0x01. 测试方法&quot;&gt;&lt;/a&gt;0x01. 测试方法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;现在安装X
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://comosk.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="移动安全" scheme="https://comosk.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
      <category term="手势密码" scheme="https://comosk.github.io/tags/%E6%89%8B%E5%8A%BF%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>移动安全测渗透测试——内存访问和修改</title>
    <link href="https://comosk.github.io/2020/03/03/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E6%B5%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9/"/>
    <id>https://comosk.github.io/2020/03/03/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E6%B5%8B%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9/</id>
    <published>2020-03-03T14:26:30.000Z</published>
    <updated>2020-03-03T14:31:22.674Z</updated>
    
    <content type="html"><![CDATA[<pre><code>通过对客户端内存的访问，木马将有可能会得到保存在内存中的敏感信息（如登录密码，帐号等）。测试客户端内存中是否存在的敏感信息（卡号、明文密码等等）。 </code></pre><h4 id="0x01-测试方法"><a href="#0x01-测试方法" class="headerlink" title="0x01 测试方法"></a>0x01 测试方法</h4><p>​    前提手机设备具有root权限，可以使用MemSpector查看、搜索和修改客户端内存数据。一般客户端上的数据一般都存放在/dev/ashmem/dalvik-heap内存段。</p><p>注：当前很多工具都是通过ptrace接口修改客户端内存，可以使用ptrace机制本身防护。</p><p>这个方法需要安装软件<a href="https://sourceforge.net/projects/appiefiles/reviews" target="_blank" rel="noopener">Appie</a>，<a href="http://memspector.apk.black/1775104-memspector-2.0/" target="_blank" rel="noopener">MemSpector</a>软件。</p><p>以上方法不能够查看上述文件信息时，可以利用DDMS配合adb shell 去设置文件权限进行导出分析对应目录下的敏感信息。</p><h4 id="0x02-威胁等级"><a href="#0x02-威胁等级" class="headerlink" title="0x02 威胁等级"></a>0x02 威胁等级</h4><p> 当进行敏感操作后在内存中可以搜索到用户输入的敏感信息时为高风险，否则无风险 。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;通过对客户端内存的访问，木马将有可能会得到保存在内存中的敏感信息（如登录密码，帐号等）。测试客户端内存中是否存在的敏感信息（卡号、明文密码等等）。 &lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;0x01-测试方法&quot;&gt;&lt;a href=&quot;#0x01-测试方法&quot; cl
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://comosk.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="移动安全" scheme="https://comosk.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>移动安全测试——adb shell命令</title>
    <link href="https://comosk.github.io/2020/03/03/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94adb-shell%E5%91%BD%E4%BB%A4/"/>
    <id>https://comosk.github.io/2020/03/03/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94adb-shell%E5%91%BD%E4%BB%A4/</id>
    <published>2020-03-03T14:24:21.000Z</published>
    <updated>2020-03-03T14:25:54.429Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：很多手机厂商会将用不到的 shell 命令移除。下面的命令大部分可以在虚拟机中执行。 </p></blockquote><h3 id="1-网络工具（root"><a href="#1-网络工具（root" class="headerlink" title="1.  网络工具（root)"></a>1.  网络工具（root)</h3><h4 id="1-1-网络接口设备配置netcfg"><a href="#1-1-网络接口设备配置netcfg" class="headerlink" title="1.1 网络接口设备配置netcfg"></a>1.1 网络接口设备配置netcfg</h4><p> 没有参数时，netcfg 可以列举当前设备的网络接口属性和状态 ,如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">λ adb shell                                                                 </span><br><span class="line">HWYAL:/ $ netcfg                                                            </span><br><span class="line">rmnet_tun11 DOWN                                   0.0.0.0/0   0x00000000   </span><br><span class="line">rmnet_emc0 DOWN                                   0.0.0.0/0   0x00000000    </span><br><span class="line">rmnet_tun01 DOWN                                   0.0.0.0/0   0x00000000   </span><br><span class="line">p2p0     UP                                     0.0.0.0/0   0x00001003      </span><br><span class="line">rmnet5   DOWN                                   0.0.0.0/0   0x00000000      </span><br><span class="line">rmnet3   DOWN                                   0.0.0.0/0   0x00000000      </span><br><span class="line">rmnet_r_ims10 DOWN                                   0.0.0.0/0   0x00000000 </span><br><span class="line">rmnet_r_ims00 DOWN                                   0.0.0.0/0   0x00000000 </span><br><span class="line">rmnet1   DOWN                                   0.0.0.0/0   0x00000000      </span><br><span class="line">rmnet_tun14 DOWN                                   0.0.0.0/0   0x00000000   </span><br><span class="line">rmnet_tun04 DOWN                                   0.0.0.0/0   0x00000000   </span><br><span class="line">rmnet_tun12 DOWN                                   0.0.0.0/0   0x00000000   </span><br><span class="line">rmnet_emc1 DOWN                                   0.0.0.0/0   0x00000000    </span><br><span class="line">rmnet_tun02 DOWN                                   0.0.0.0/0   0x00000000   </span><br><span class="line">rmnet_tun10 DOWN                                   0.0.0.0/0   0x00000000   </span><br><span class="line">ip6_vti0 DOWN                                   0.0.0.0/0   0x00000080      </span><br><span class="line">rmnet6   DOWN                                   0.0.0.0/0   0x00000000      </span><br><span class="line">rmnet_tun00 DOWN                                   0.0.0.0/0   0x00000000   </span><br><span class="line">dummy0   UP                                     0.0.0.0/0   0x000000c3      </span><br><span class="line">sit0     DOWN                                   0.0.0.0/0   0x00000080      </span><br><span class="line">lo       UP                                   127.0.0.1/8   0x00000049      </span><br><span class="line">rmnet4   DOWN                                   0.0.0.0/0   0x00000000      </span><br><span class="line">wlan0    UP                               192.168.11.36/24  0x00001043      </span><br><span class="line">rmnet_r_ims11 DOWN                                   0.0.0.0/0   0x00000000 </span><br><span class="line">rmnet_r_ims01 DOWN                                   0.0.0.0/0   0x00000000 </span><br><span class="line">rmnet2   DOWN                                   0.0.0.0/0   0x00000000      </span><br><span class="line">Hisilicon0 DOWN                                   0.0.0.0/0   0x00001002    </span><br><span class="line">ip6tnl0  DOWN                                   0.0.0.0/0   0x00000080      </span><br><span class="line">ip_vti0  DOWN                                   0.0.0.0/0   0x00000080      </span><br><span class="line">rmnet0   DOWN                                   0.0.0.0/0   0x00000000      </span><br><span class="line">rmnet_tun13 DOWN                                   0.0.0.0/0   0x00000000   </span><br><span class="line">rmnet_tun03 DOWN                                   0.0.0.0/0   0x00000000   </span><br><span class="line">rmnet_ims10 DOWN                                   0.0.0.0/0   0x00000000   </span><br><span class="line">rmnet_ims00 DOWN                                   0.0.0.0/0   0x00000000</span><br></pre></td></tr></tbody></table></figure><p>通过<code>netcfg rmnet0 up</code>可以打开rmnet0设备（需要root权限），与ifconfig类似。</p><h4 id="1-2-嗅探流量tcpdump"><a href="#1-2-嗅探流量tcpdump" class="headerlink" title="1.2  嗅探流量tcpdump"></a>1.2  嗅探流量tcpdump</h4><span class="label primary"> tcpdump</span> 程序可以嗅探指定网络接口的所有网络流量。常用命令行如下所示:<blockquote><ul><li>-i     指定监听所有网络接口</li><li>-p    指定禁用混杂模式</li><li>-s 0  指定捕获完整数据包</li><li>-w    指定输出文件</li></ul></blockquote><p><code>Ctrl+c</code>终止tcpdump的执行，得到SD卡上的<code>capture.pcap</code>文件后，结合PC上的Wireshark进一步分析。</p><p>详细参考：<a href="https://cizixs.com/2015/03/12/tcpdump-introduction/" target="_blank" rel="noopener">抓包神器 tcpdump 使用介绍</a></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell tcpdump -i any -p -s 0 -w /sdcard/capture.pcap</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whyred:/ # tcpdump -i any -p -s 0 -w /sdcard/capture.pcap</span><br><span class="line">tcpdump: listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes</span><br></pre></td></tr></tbody></table></figure><h4 id="1-3-监控流量"><a href="#1-3-监控流量" class="headerlink" title="1.3 监控流量"></a>1.3 监控流量</h4><p> Android 系统中的 iftop 命令可以用来监控网卡的实时流量。 详细参考：<a href="https://www.cnblogs.com/chenqionghe/p/10680075.html" target="_blank" rel="noopener">从零开始学习iftop流量监控</a></p><h3 id="2-进程查看和监视-ps-top"><a href="#2-进程查看和监视-ps-top" class="headerlink" title="2  进程查看和监视 ps/top"></a>2  进程查看和监视 ps/top</h3><p> <code>ps</code> 列举进程，如下所示，最后一列为进程名，第二列是 PID。使用<code>ps -T</code>可以查看进程 的线程信息。 </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1|whyred:/ $ ps -T</span><br><span class="line">USER           PID   TID  PPID     VSZ    RSS WCHAN            ADDR S CMD</span><br><span class="line">shell        29341 29341 27842   11552   2040 sigsuspend 7f729cbe10 S sh</span><br><span class="line">shell        30319 30319 29341   14144   2232 0          7057e95770 R ps</span><br></pre></td></tr></tbody></table></figure><p> <code>top</code> 用于监控系统中所有进程的状态。如下所示，第一行是系统的 CPU 占用情况。 </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Tasks: 701 total,   2 running, 695 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Mem:   2805712k total,  2403632k used,   402080k free,    12716k buffers</span><br><span class="line">Swap:  1048572k total,   614172k used,   434400k free,   669548k cached</span><br><span class="line"><span class="meta">800%</span><span class="bash">cpu  17%user   8%nice  21%sys 749%idle   2%iow   2%irq   1%sirq   0%host</span></span><br><span class="line">  PID USER         PR  NI VIRT  RES  SHR S[%CPU] %MEM     TIME+ ARGS</span><br><span class="line">  686 system       20   0  99M 1.9M 1.9M S 11.3   0.0  14:17.84 android.hardware.sensors@1.0-serv+ 1962 system       18  -2 4.7G 309M 267M S 10.6  11.2  15:45.66 system_server</span><br><span class="line">26672 u0_a193      20   0 1.2G  42M  34M S  9.6   1.5   2:13.49 com.gaiaworkforce.mobile:remote</span><br><span class="line">30408 shell        20   0  14M 2.9M 1.6M R  4.0   0.1   0:00.22 top</span><br><span class="line"> 3094 system       20   0  17M 2.2M 1.5M S  4.0   0.0  10:31.33 cnss_diag -q -f</span><br><span class="line">24156 root         20   0    0    0    0 S  2.3   0.0   0:23.21 [kworker/u16:4]</span><br><span class="line"> 2687 radio        20   0 3.8G  56M  44M S  2.0   2.0   3:01.75 com.android.phone</span><br><span class="line">30090 root         20   0    0    0    0 R  1.3   0.0   0:02.92 [kworker/u16:2]</span><br><span class="line"> 4297 u0_a112      20   0 3.7G  45M  34M S  1.3   1.6   3:12.03 com.lbe.security.miui</span><br><span class="line">29134 root         20   0    0    0    0 S  1.0   0.0   0:05.94 [kworker/u16:7]</span><br><span class="line">30119 root         20   0    0    0    0 S  0.6   0.0   0:00.72 [kworker/0:2]</span><br><span class="line">26501 u0_a193      20   0 1.4G 170M  61M S  0.6   6.1   0:28.62 com.gaiaworkforce.mobile</span><br><span class="line">  690 wifi         20   0  24M 4.9M 2.0M S  0.6   0.1   1:51.80 android.hardware.wifi@1.0-service</span><br><span class="line">  569 system       20   0  14M 1.7M 1.4M S  0.6   0.0   0:42.66 servicemanager</span><br><span class="line">  449 root         -2   0    0    0    0 D  0.6   0.0   1:05.10 [mmc-cmdqd/0]</span><br><span class="line">26588 u0_a193      20   0 1.2G  38M  33M S  0.3   1.3   0:14.06 com.gaiaworkforce.mobile:core</span><br><span class="line">26551 u0_a193      20   0 1.2G  46M  35M S  0.3   1.6   0:14.79 com.gaiaworkforce.mobile:pushcore 26532 mdnsr        20   0 5.6M 708K 292K S  0.3   0.0   0:02.42 mdnsd</span><br><span class="line"> 6290 u0_a21       20   0 1.9G  51M  33M S  0.3   1.8   1:17.14 com.browser_llqhz</span><br><span class="line"> 4498 system       20   0 3.8G  52M  40M S  0.3   1.8   0:21.71 com.miui.powerkeeper</span><br><span class="line"> 3589 u0_a46       20   0 4.3G  57M  45M S  0.3   2.0   2:01.79 com.androidmarket</span><br></pre></td></tr></tbody></table></figure><h3 id="3-系统调用记录-Strace"><a href="#3-系统调用记录-Strace" class="headerlink" title="3 系统调用记录 Strace"></a>3 系统调用记录 Strace</h3><p> strace 命令可以截获并记录进程执行的系统调用以及进程接收的信号。每个系统调用的名 称、参数以及返回值都将被输出。</p><blockquote><ul><li>strace 命令有很多参数，常用命令行<code>strace -f -ff -x -v -F -s 512 -o logfile -p pid</code>，即监控进程号 pid 的进程中所有线程的系统调用，输出到以 logfile 为起 始的多个文件中（每个进程一个文件）。</li><li>strace 的-e 选项可以过滤记录。如<code>strace -e trace=file</code>将只跟踪以文件名为参数的函数 调用，<code>strace -e trace=open,close,rean,write</code>将只跟踪 open,close,rean,write 四个系统调用。 </li></ul></blockquote><p>详细参考<a href="https://www.iteye.com/blog/logo32-1312444" target="_blank" rel="noopener">Strace命令用法</a>和<a href="https://linux.die.net/man/1/strace" target="_blank" rel="noopener">Strace手册</a></p><h3 id="4-事件操作-getevent-sendevent"><a href="#4-事件操作-getevent-sendevent" class="headerlink" title="4  事件操作 getevent/sendevent"></a>4  事件操作 getevent/sendevent</h3><p> 此命令需要 root 权限。可监控和模拟鼠标事件，按键事件，拖动滑动等等。使用-p 选项 可得到设备属性 </p><blockquote><p>getevent&amp;sendevent 是android系统下的一个工具，可以 模拟多种按键和触屏操作，产生的是raw event，raw event经过event hub处理产生最终的gesture事件。 </p><p><strong>sendevent :</strong>命令格式 : <strong>sendevent</strong> [device][type] [<strong>code</strong>][value]</p></blockquote><p> 注意的是在 getevent 中code显示的是<strong>十六进制</strong>, 而sendevent 中需要用十进制</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">whyred:/ # getevent -p</span><br><span class="line">add device 1: /dev/input/event8</span><br><span class="line">  name:     "uinput-fpc"</span><br><span class="line">  events:</span><br><span class="line">    KEY (0001): 0060  0067  0069  006a  006c  0130  0131  0132</span><br><span class="line">                0133  0134</span><br><span class="line">  input props:</span><br><span class="line">    &lt;none&gt;</span><br><span class="line">add device 2: /dev/input/event7</span><br><span class="line">  name:     "sdm660-snd-card Button Jack"</span><br><span class="line">  events:</span><br><span class="line">    KEY (0001): 00e2  0101  0102  0103  0104  0105</span><br><span class="line">  input props:</span><br><span class="line">    INPUT_PROP_ACCELEROMETER</span><br><span class="line">add device 3: /dev/input/event6</span><br><span class="line">  name:     "sdm660-snd-card Headset Jack"</span><br><span class="line">  events:</span><br><span class="line">    SW  (0005): 0002  0004  0006  0007  000f  0010  0011  0012</span><br><span class="line">  input props:</span><br><span class="line">    &lt;none&gt;</span><br><span class="line">add device 4: /dev/input/event4</span><br><span class="line">  name:     "hall-switch-input"</span><br><span class="line">  events:</span><br><span class="line">    KEY (0001): 0284  0285</span><br><span class="line">    SW  (0005): 0000</span><br><span class="line">  input props:</span><br><span class="line">    INPUT_PROP_ACCELEROMETER</span><br></pre></td></tr></tbody></table></figure><p> 指定设备文件，则监听相应设备的事件。 </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getevent  /dev/input/event2</span><br></pre></td></tr></tbody></table></figure><h3 id="5-文件列举lsof"><a href="#5-文件列举lsof" class="headerlink" title="5 文件列举lsof"></a>5 文件列举lsof</h3><p> Android 中的 lsof 命令可以显示所有进程打开的文件。其中第一列为打开文件的进程 pid， 第二列是进程名，第三列是打开的文件名。 </p><h3 id="6-数据库文件查看sqlite3"><a href="#6-数据库文件查看sqlite3" class="headerlink" title="6 数据库文件查看sqlite3"></a>6 数据库文件查看sqlite3</h3><p> sqlite3 的命令可以让用户手工输入并执行面向 SQLite 数据库的 SQL 命令。系统命令以. 开头，可以通过.help 命令详细查看。SQL 命令须以;结尾。首先以 db 文件为参数进入 sqlite3 命令行，然后就可以对挂载的数据库进行操作。  </p><p>DDMS也可以将文件导出，然后使用<code>navicat permium</code>查看</p><h3 id="7-日志查看"><a href="#7-日志查看" class="headerlink" title="7 日志查看"></a>7 日志查看</h3><p> 命令行输入 adb logcat 可以查看 android 输出的日志记录。Android SDK 中的 DDMS 可 以查看日志记录。 </p><h3 id="8-测试工具Monkey"><a href="#8-测试工具Monkey" class="headerlink" title="8 测试工具Monkey"></a>8 测试工具Monkey</h3><p> Monkey 是一个命令行工具，可以运行在模拟器里或实际设备中。它向系统发送伪随机的 用户事件流，实现对正在开发的应用程序进行压力测试。-p 选项指定了测试的包名，参数 100 是随机模拟事件的次数。在命令执行过程中，设备会接受 monkey 产生的随机时间，画面也会随机切换。 </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monkey -p com.packagename -v 100</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;注：很多手机厂商会将用不到的 shell 命令移除。下面的命令大部分可以在虚拟机中执行。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-网络工具（root&quot;&gt;&lt;a href=&quot;#1-网络工具（root&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="移动安全" scheme="https://comosk.github.io/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="adb" scheme="https://comosk.github.io/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>正确刷入一个第三方Recovery</title>
    <link href="https://comosk.github.io/2020/03/03/%E6%AD%A3%E7%A1%AE%E5%88%B7%E5%85%A5%E4%B8%80%E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9Recovery/"/>
    <id>https://comosk.github.io/2020/03/03/%E6%AD%A3%E7%A1%AE%E5%88%B7%E5%85%A5%E4%B8%80%E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9Recovery/</id>
    <published>2020-03-03T14:13:27.000Z</published>
    <updated>2020-03-03T14:23:27.853Z</updated>
    
    <content type="html"><![CDATA[<p>概述：什么是Recovery，Recovery的定位的确很类似PC平台的WinPE。它本质上是一个非常精简的Linux，用以读写System分区（安卓系统主体）、Boot分区（内核）的内容。 使用Recovery来root就只需要点选相应是su文件，然后刷入System分区即可。 </p><p>注：{ % info@label ROM包 %}是手机的系统包。刷机就是把ROM包刷到手机中去，然后达到更新手机系统的目的。RoM包一般都是ZIP、RAR等压缩包格式或者其他后缀的样式，依品牌的不同而有区别。</p><p>卡刷机需要下载ROM，但不需要解压，直接放到手机内存根目录，通过Recovery模式刷入即可。手机ROM一般手机官网都会提供相应的下载。</p><h4 id="0x01-找到需要下载的第三方Recovery"><a href="#0x01-找到需要下载的第三方Recovery" class="headerlink" title="0x01 找到需要下载的第三方Recovery"></a>0x01 找到需要下载的第三方Recovery</h4><ol><li>查看支持的<a href="https://twrp.me/Devices/" target="_blank" rel="noopener">设备列表</a></li><li>根据设备型号下载相应的映像文件.img</li><li>下载相应的SDK中或单独下载一个platform-tools工具包，这个platform-tools目录下存在我们需要的两个文件，一个是<code>adb.exe</code> 另一个是<code>fastboot.exe</code></li><li>将下载的映像文件放到platform-tools目录下</li></ol><h4 id="0x02-进行刷入第三方Recovery步骤"><a href="#0x02-进行刷入第三方Recovery步骤" class="headerlink" title="0x02 进行刷入第三方Recovery步骤"></a>0x02 进行刷入第三方Recovery步骤</h4><ol><li><p>需要进入快启动fastboot模式，每个手机厂商的不同，有的是声音下+关机</p></li><li><p>若是配置好驱动程序，就可以使用计算机上的命令提示符，输入以下命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></tbody></table></figure></li><li><p>将platform-tools目录下的映像文件改名为terp.img，然后将次第三方Recovery刷到手机上，命令如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash recovery terp.img</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></tbody></table></figure></li><li><p>也可以在root的手机上，通过adb shell或终端模拟仿真器上运行以下命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line">dd if = /scard/twrp.img of = /dev/block/bootdevice/by-name/recovery</span><br></pre></td></tr></tbody></table></figure></li><li><p>这样就安装好了第三方Recovery，就可以刷、root、Xpoosed</p></li></ol><p>注：最好第一次重启到recovery模式。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;概述：什么是Recovery，Recovery的定位的确很类似PC平台的WinPE。它本质上是一个非常精简的Linux，用以读写System分区（安卓系统主体）、Boot分区（内核）的内容。 使用Recovery来root就只需要点选相应是su文件，然后刷入System分区
      
    
    </summary>
    
    
      <category term="移送安全" scheme="https://comosk.github.io/categories/%E7%A7%BB%E9%80%81%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Xposed" scheme="https://comosk.github.io/tags/Xposed/"/>
    
  </entry>
  
  <entry>
    <title>Xposed框架安装</title>
    <link href="https://comosk.github.io/2020/03/03/Xposed%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85/"/>
    <id>https://comosk.github.io/2020/03/03/Xposed%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85/</id>
    <published>2020-03-03T13:00:43.000Z</published>
    <updated>2020-03-03T13:03:59.132Z</updated>
    
    <content type="html"><![CDATA[<h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p><strong>【通过XposedInstall安装】</strong></p><p><a href="https://repo.xposed.info/module/de.robv.android.xposed.installer" target="_blank" rel="noopener">Xposed官网</a></p><p><a href="https://forum.xda-developers.com/showthread.php?t=3034811" target="_blank" rel="noopener">下载地址</a></p><p>点击【未激活】下面的【云彩】选择install 进行安装</p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>通过第三方Recovery手动刷入ZIP安装包，安装包在手机厂商对应的对应的论坛中寻找，出现意外卡logo，就需要下载<a href="http://dl-xda.xposed.info/framework/uninstaller/" target="_blank" rel="noopener">卸载包</a>，通过第三方recovery刷入即可。</p><p><a href="https://forum.xda-developers.com/showthread.php?p=58828974" target="_blank" rel="noopener">XposedInstaller下载地址</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;方法一：&quot;&gt;&lt;a href=&quot;#方法一：&quot; class=&quot;headerlink&quot; title=&quot;方法一：&quot;&gt;&lt;/a&gt;方法一：&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;【通过XposedInstall安装】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://r
      
    
    </summary>
    
    
      <category term="移动安全" scheme="https://comosk.github.io/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Xposed框架" scheme="https://comosk.github.io/tags/Xposed%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>DNS域名解析过程详解</title>
    <link href="https://comosk.github.io/2020/03/01/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://comosk.github.io/2020/03/01/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-03-01T14:43:49.000Z</published>
    <updated>2020-03-01T15:06:12.213Z</updated>
    
    <content type="html"><![CDATA[<p>​    信息收集对于渗透测试来说是重要的第一步，所以当然离不开whois,whois是用来查看域名的IP以及所有者的信息的传输协议。可以查看注册的域名所有人等。上面可以进行爆破邮箱、社工、域名劫持等方法攻击，下面详细讲解DNS解析过程。</p><img src="https://bkimg.cdn.bcebos.com/pic/4e4a20a4462309f72ac61ab6720e0cf3d6cad6ed?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2UxNTA=,xp_5,yp_5" class="nofancybox">  <h3 id="0x01-根域"><a href="#0x01-根域" class="headerlink" title="0x01 根域"></a>0x01 根域</h3><p>其实就是所谓的“.”，所有网站的完整形式都有最后的一个点。即<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>. 。但习惯省略了后面的点。</p><p>域名是分级的，所以域名解析也是分级的，本地DNS服务器不存在我们查找的域名IP地址时，下一步就会直接向根域名DNS服务器进行发出解析请求。</p><p>根域服务器只有13个IP地址，但机器不仅仅只有13个。IP地址是借助传播的技术的，所以我们可以在全球都可以访问到这些IP的镜像站点。</p><p>kali liunx提供一个dig命令来查看相关信息：dig 指定站点</p><h3 id="0x02-域的划分"><a href="#0x02-域的划分" class="headerlink" title="0x02 域的划分"></a>0x02 域的划分</h3><p>根域下来就是一级域也叫顶级域</p><blockquote><p>两种划分方式：按行业性质和按国家</p><ul><li>按行业：.com  .org ……</li><li>按国家：.cn   .jp  .us</li></ul></blockquote><p>每个域都有自己的域名服务器，也叫权威域名服务器</p><p>一级域名之后还有二级域名、三级域名。而且只要买了一个顶级域名，搭建了自己BIND服务器注册测到互联网中，就可以随意的多加几个域了。</p><h3 id="0x03-域名服务器"><a href="#0x03-域名服务器" class="headerlink" title="0x03 域名服务器"></a>0x03 域名服务器</h3><p>提供域名解析的服务器，上面的记录可以是A(address)记录，NS(nameserver)记录，MX(mail)，CNAME等。</p><ul><li><p>A记录</p><p>又称IP指向。在此设置子域名并且指向自己的目标主机地址上，从而实现通过域名找到都武器。注：指向目标主机地址，只能使用IP地址</p><blockquote><ul><li>泛域名解析：指将该域名所有未指定的子域名都指向一个地址。在主机名：*| 类型：A|IP地址/主机名：IP地址</li><li>SLB（负载均衡Server load balancing）：指在一系列资源上动态分布网络负载。相同子域名有多个目标地址时，即是轮询，达到SLB，但需要虚拟主机服务商支持</li></ul></blockquote></li><li><p>CNAME</p><p>通常称为别名指向。为自己的主机设置一个别名，例test.com，用来指向<a href="http://www.abcd.com，以后就可以用test.com来代替访问www.abcd.com了。" target="_blank" rel="noopener">www.abcd.com，以后就可以用test.com来代替访问www.abcd.com了。</a></p><p>CNAME中目标地址只能使用主机名，不能使用IP地址，主机名前面不能有任何前缀如https://</p><div class="note info">            <p>注：A记录优于CNAME记录。即两者同时存在，CNAME不生效。</p>          </div></li><li><p>MX记录</p><p>邮件交换记录。用于以该域名为结尾的电子邮件指向对应的邮件服务器进行处理。例邮件是以域名testabcd.com结尾的，那么管理界面添加该域名的MX记录来处理所有@testabcd.com结尾的邮件。</p><blockquote><p>MX记录可以使用主机或IP地址。可以设置优先级实现主辅服务器设置，优先级中数字越小，优先级越高。相同的数字实现负载均衡。</p><p>如果在“主机名”中填入子域名则此MX记录只对该子域名生效。</p><p>当域名的MX记录有多个目标地址且优先级相同时，表示轮循，可以达到负载均衡的目的</p></blockquote></li><li><p>NS记录</p><blockquote><p>解析服务器记录。用来表明由哪台服务器对该域名进行解析。 只对子域名生效。 </p></blockquote><div class="note info">            <p>注：NS记录高于A记录。</p>          </div><p>注：TTL值TTL值全称是“生存时间（ Time To Live)” ，简单的说它表示DNS记录在 DNS服务器上缓存时间 </p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      信息收集对于渗透测试来说是重要的第一步，所以当然离不开whois,whois是用来查看域名的IP以及所有者的信息的传输协议。下面详细讲解DNS解析过程。
    
    </summary>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="DNS解析" scheme="https://comosk.github.io/tags/DNS%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>绕过CDN查看真实IP方法</title>
    <link href="https://comosk.github.io/2020/03/01/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E7%9C%8B%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95/"/>
    <id>https://comosk.github.io/2020/03/01/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E7%9C%8B%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95/</id>
    <published>2020-03-01T13:45:54.000Z</published>
    <updated>2020-03-01T13:51:01.434Z</updated>
    
    <content type="html"><![CDATA[<p>绕过CND查看网站真实IP的一些方法</p><h5 id="0x01-验证是否存在CDN最简单的方法"><a href="#0x01-验证是否存在CDN最简单的方法" class="headerlink" title="0x01. 验证是否存在CDN最简单的方法"></a>0x01. 验证是否存在CDN最简单的方法</h5><blockquote><p>通过在线的多地ping，即通过每个地区ping的结果的得到IP</p><p>看这些IP是否一直，如果都是一样的，极大可能不存在CDN，但不绝对</p><p>如果这些IP大多都不太一样，或者规律性很强，可以尝试查询这些IP的归属地，判断是否都存在CDN</p></blockquote><h5 id="0x02-验证IP和域名是否真实对应最简单的办法"><a href="#0x02-验证IP和域名是否真实对应最简单的办法" class="headerlink" title="0x02. 验证IP和域名是否真实对应最简单的办法"></a>0x02. 验证IP和域名是否真实对应最简单的办法</h5><blockquote><p>修改本地hosts文件，强行将域名与IP解析对应</p><p>然后访问域名页面是否发生变化</p><ol><li><p><code>ping</code></p><p>假设存在CDN</p><p>ping www.域名.com 是不通的</p><p>尝试 ping 域名.com</p><p>很多厂商可能让www使用CDN，空域名不使用CDN缓存</p><p>即直接ping 域名，可能得到真实IP</p></li><li><p>分站域名</p><p>很多网站主站的访问量比较大，所以主站都是挂CDN，但分站不一定使用CDN</p><p>这个时候可以尝试去查看相应分站IP。推荐<code>Zoomeye.org</code>，<code>shodan.io</code>，<code>fofa</code>。都可以选择</p></li><li><p>国外访问</p><p>国内的CDN往往只针对国内用户访问加速，所以国外就不一定。即使用国外代理访问就能查看真实的IP了</p><p>利用国外的DNS解析，就有可能得到真实IP</p></li></ol></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      有些网站的IP进行使用了CDN（内容分发网络），导致IP随着不同地方的访问，所得到的IP地址是不同的，这个时候我你们怎么绕过CDN查看真实IP地址
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://comosk.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="信息收集" scheme="https://comosk.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试之信息收集【2020.3.1记】</title>
    <link href="https://comosk.github.io/2020/03/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E3%80%902020-3-1%E8%AE%B0%E3%80%91/"/>
    <id>https://comosk.github.io/2020/03/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E3%80%902020-3-1%E8%AE%B0%E3%80%91/</id>
    <published>2020-03-01T13:42:57.000Z</published>
    <updated>2020-03-01T13:45:07.308Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Web信息收集"><a href="#1-Web信息收集" class="headerlink" title="1. Web信息收集"></a>1. Web信息收集</h3><h4 id="0x01-网站源码脚本"><a href="#0x01-网站源码脚本" class="headerlink" title="0x01 网站源码脚本"></a>0x01 网站源码脚本</h4><blockquote><p>伪静态 :不是真正的静态格式文件 </p><p>利用F12查看更多的信息，查看相应的开发语言，如果简单的一次看不出来，可以多发送几次数据包，然后进行目录扫描的时候，例如<code>御剑</code>，选择相应的字典类型。</p><p>F12进入开发者模式，在network中多提交地址访问抓包分析，在requset和response来回的数据包中去发现更多的信息。</p></blockquote><h4 id="0x02-Web指纹识别"><a href="#0x02-Web指纹识别" class="headerlink" title="0x02. Web指纹识别"></a>0x02. Web指纹识别</h4><blockquote><p>Web应用是利用cms进行搭建的，进行CMS进行相应的识别后，可以查看更多的信息</p><p>平台：搜索引擎去搜索Web指纹识别</p><p>工具：<code>cmsmap</code> <code>御剑cms</code></p></blockquote><h4 id="0x03-网站对应数据库"><a href="#0x03-网站对应数据库" class="headerlink" title="0x03. 网站对应数据库"></a>0x03. 网站对应数据库</h4><blockquote><p>常用的数据库组合匹配，php:mysql aspx:mssql asp:access |jsp:mysql/oracle py:mongodb</p><p>端口扫描判断<code>zenmap</code> <code>masscan</code>：内网服务器方法失效</p><p>常见数据库端口：mysql:3306 mssql:1433 oracle:1521,详细见<a href="https://www.cnblogs.com/botoo/p/10475402.html" target="_blank" rel="noopener">端口渗透总结</a></p></blockquote><h4 id="0x04-网站搭建平台"><a href="#0x04-网站搭建平台" class="headerlink" title="0x04. 网站搭建平台"></a>0x04. 网站搭建平台</h4><blockquote><p>查看元素或审查元素抓包获取</p></blockquote><h4 id="0x05-服务器操作系统"><a href="#0x05-服务器操作系统" class="headerlink" title="0x05. 服务器操作系统"></a>0x05. 服务器操作系统</h4><blockquote><p>大小写判断Windows大小写不敏感，liunx相反</p></blockquote><h4 id="0x06-robots协议"><a href="#0x06-robots协议" class="headerlink" title="0x06. robots协议"></a>0x06. robots协议</h4><blockquote><p>写给搜索引擎看的，搜索殷勤去爬行数据时，有选择的爬行。</p><p>查看方法直地址/robots.txt获取</p></blockquote><h3 id="2-端口信息收集"><a href="#2-端口信息收集" class="headerlink" title="2. 端口信息收集"></a>2. 端口信息收集</h3><h4 id="0x01-服务协议对应"><a href="#0x01-服务协议对应" class="headerlink" title="0x01. 服务协议对应"></a>0x01. 服务协议对应</h4><blockquote><p><a href="https://www.cnblogs.com/botoo/p/10475402.html" target="_blank" rel="noopener">端口渗透总结</a></p></blockquote><h4 id="0x02-Web端口对应"><a href="#0x02-Web端口对应" class="headerlink" title="0x02. Web端口对应"></a>0x02. Web端口对应</h4><blockquote><p>搜索引擎去查看打开8080端口的，inurl:8080，如果不加8080和加8080是不同的目标，这就是两个目标</p></blockquote><h3 id="3-目录信息收集"><a href="#3-目录信息收集" class="headerlink" title="3. 目录信息收集"></a>3. 目录信息收集</h3><h4 id="0x01-敏感文件"><a href="#0x01-敏感文件" class="headerlink" title="0x01. 敏感文件"></a>0x01. 敏感文件</h4><blockquote><p>工具：<code>WebPathBrute[御剑实战靶场]</code></p><p>备份文件、数据库备份文件、源码备份文件等</p><p>说明文件、源码说明、其他说明等</p></blockquote><h4 id="0x02-目录站点"><a href="#0x02-目录站点" class="headerlink" title="0x02. 目录站点"></a>0x02. 目录站点</h4><blockquote><p>不同的搭建不同的地址</p></blockquote><h4 id="0x03-爬行目录"><a href="#0x03-爬行目录" class="headerlink" title="0x03. 爬行目录"></a>0x03. 爬行目录</h4><blockquote><p>扫描工具对其进行扫描，其中可能包括后台地址</p><p>工具：layer子域名挖掘机。或kali命令：dirb</p></blockquote><h4 id="0x04-扫描目录"><a href="#0x04-扫描目录" class="headerlink" title="0x04. 扫描目录"></a>0x04. 扫描目录</h4><blockquote><p>通过字典扫描可能存在的页面，主要扫描后台和上传目录</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      渗透测试开始时要更多更全面的进行信息的收集，包括Web信息收集，端口信息收集，目录信息收集……
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://comosk.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="信息收集" scheme="https://comosk.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Web安全渗透测试常见下手方式</title>
    <link href="https://comosk.github.io/2020/03/01/Web%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E4%B8%8B%E6%89%8B%E6%96%B9%E5%BC%8F/"/>
    <id>https://comosk.github.io/2020/03/01/Web%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E4%B8%8B%E6%89%8B%E6%96%B9%E5%BC%8F/</id>
    <published>2020-03-01T13:31:26.000Z</published>
    <updated>2020-03-01T13:34:54.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-基于Web的安全漏洞的渗透✒️"><a href="#0x01-基于Web的安全漏洞的渗透✒️" class="headerlink" title="0x01 基于Web的安全漏洞的渗透✒️"></a>0x01 基于Web的安全漏洞的渗透✒️</h3><blockquote><ol><li>主要是针对Web应用进行安全测试，从Web下手</li><li>检测有没有SQL注入，XSS等漏洞，然后针对漏洞进行攻击</li></ol></blockquote><h3 id="0x02-基于Web的CMS漏洞的渗透👶"><a href="#0x02-基于Web的CMS漏洞的渗透👶" class="headerlink" title="0x02 基于Web的CMS漏洞的渗透👶"></a>0x02 基于Web的CMS漏洞的渗透👶</h3><blockquote><ol><li>通过对CMS系统的一个指纹识别，去查看使用的第三方软件和服务器，开发语言之类的信息</li><li>主要有两种方式，方式一:平台，通过搜索引擎<code>搜索Web指纹识别</code></li><li>另一种方式：利用工具<code>cmsmap</code> <code>御剑CMS</code></li></ol></blockquote><h3 id="0x03-基于Web和端口结合的渗透💙"><a href="#0x03-基于Web和端口结合的渗透💙" class="headerlink" title="0x03 基于Web和端口结合的渗透💙"></a>0x03 基于Web和端口结合的渗透💙</h3><blockquote><ol><li>对域名地址无从下手，选择利用端口进行入手</li><li>采用工具<code>zenmap</code>或<code>nmap</code>进行全部端口的扫描探针</li><li>扫描端口结果后在域名后面进行：域名/IP+端口号</li><li>查看有几个站点，如果不是站点，可以进行目录扫描</li></ol></blockquote><blockquote><p>意义：在于端口这个地方也是一个机会。</p></blockquote><h3 id="0x04-基于Web目录结构上的渗透🗂"><a href="#0x04-基于Web目录结构上的渗透🗂" class="headerlink" title="0x04 基于Web目录结构上的渗透🗂"></a>0x04 基于Web目录结构上的渗透🗂</h3><blockquote><ol><li>管理员之类的忽视的一个问题，设置不当</li><li>网站其他目录可能也是一个程序应用</li><li>利用爬虫进行爬行进行目录扫描，相应工具<code>御剑</code> <code>dirb</code></li></ol></blockquote><h3 id="0x05-基于Web域名结构上的渗透⛹️‍♀️"><a href="#0x05-基于Web域名结构上的渗透⛹️‍♀️" class="headerlink" title="0x05 基于Web域名结构上的渗透⛹️‍♀️"></a>0x05 基于Web域名结构上的渗透⛹️‍♀️</h3><blockquote><ol><li>如果域名上无从下手的话，可以从子域名上进行入手</li><li>可以寻找相应的子域名和二级域名，利用工具<code>layer子域名挖掘机</code></li><li><code>layer子域名挖掘机</code>原理是通过字典-&gt;枚举接口-&gt;进行前缀名的拼接。</li><li>查看是否是同一IP最好，如果不是同一IP可以查看是否是同一网段，从内网下手</li><li>利用搜索引擎进行查看子域名，<code>site:baidu.com</code>，<code>inurl:baidu.com</code>接下来利用脚本去爬行域名结果</li><li>工具有的利用字典，有的利用爆破</li></ol></blockquote><h3 id="0x06-基于中间件平台漏洞的渗透👤"><a href="#0x06-基于中间件平台漏洞的渗透👤" class="headerlink" title="0x06 基于中间件平台漏洞的渗透👤"></a>0x06 基于中间件平台漏洞的渗透👤</h3><blockquote><ol><li>类似于<code>IIS</code> <code>tomcat</code> <code>apache</code> <code>Nginx</code>等中间件常见漏洞，细看常见Web中间件常见漏洞总结</li><li>发现这些漏洞，一些扫描工具进行一些探针，或者是发现这些服务器，信息收集的时候去搜索相应的漏洞。</li><li><code>IIS</code>利用工具<code>Netsparker</code>去扫描</li></ol></blockquote><h3 id="0x07-基于第三方软件漏洞的渗透🤙"><a href="#0x07-基于第三方软件漏洞的渗透🤙" class="headerlink" title="0x07 基于第三方软件漏洞的渗透🤙"></a>0x07 基于第三方软件漏洞的渗透🤙</h3><blockquote><ol><li>查看相应IP地址，利用ping:域名，得到IP地址</li><li>利用端口扫描，利用协议去查看哪些服务，第三方软件，服务一搬利用端口</li><li>利用端口进行访问，查看服务器软件，搜索相应的漏洞，查看攻击方式</li></ol></blockquote><blockquote><p>利用端口扫描然后查找第三方软件，然后搜索第三方软件的漏洞，然后进行尝试攻吉</p></blockquote><h3 id="0x08-基于服务器系统漏洞的渗透🗡"><a href="#0x08-基于服务器系统漏洞的渗透🗡" class="headerlink" title="0x08 基于服务器系统漏洞的渗透🗡"></a>0x08 基于服务器系统漏洞的渗透🗡</h3><blockquote><ol><li>针对系统的漏洞利用相对专业的系统扫描工具，例<code>openvs</code> <code>nessus</code></li><li>注：经常进行更新nessus，使用相应的插件plugins</li><li>然后选择常用的advanced Scan进行扫描，Target可以使用IP地址</li><li>查看扫描结果查看漏洞介绍，进行相应的漏洞利用</li></ol></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      针对Web安全渗透测试常见的下手方式，在Web应用无从下手的时候，也可以选择Web的CMS漏洞，端口方面，域名结构，目录等方面进行下手。
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://comosk.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>XSS攻击方式及防御措施</title>
    <link href="https://comosk.github.io/2020/02/29/XSS%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD/"/>
    <id>https://comosk.github.io/2020/02/29/XSS%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD/</id>
    <published>2020-02-29T03:58:27.000Z</published>
    <updated>2020-02-29T04:00:40.839Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前端XSS攻击分类"><a href="#0x01-前端XSS攻击分类" class="headerlink" title="0x01 前端XSS攻击分类"></a>0x01 前端XSS攻击分类</h3><ul><li><p>什么是XSS?</p><p>XSS允许恶意的Web用户将代码植入到提供给其他用户使用的页面中</p><ol><li>攻击者往网页里注入恶意脚本代码</li><li>当用户访问包含恶意代码的网页时</li><li>通过恶意脚本攻击者可以获取和控制用户信息</li></ol></li><li><p>XSS分类</p><ol><li><p>反射型（非持久型）XSS</p><p>​    诱导用户点击带有恶意脚本的URL，而服务器直接使用了恶意脚本并返回了结果页，从而导致恶意代码在浏览器执行。</p><p>​    点击恶意URL，导致恶意代码的执行。</p></li></ol></li></ul><p>  ​    src=“js”发送一个ajax请求，获取信息。</p><p>  注：防止XSS获取Cookie值得方式，去设置一个httponly标志，防止客户端获取cookie。</p><ol><li><p>存储型（持久型）XSS</p><p>将恶意代码上传或存储到了漏洞服务器上，用户访问页面时，页面中包含恶意脚本。</p></li><li><p>攻击者将恶意代码上传到服务器</p><ol><li>访问包含恶意脚本的页面</li></ol></li><li><p>服务器读取恶意数据且直接使用</p><ol><li>服务器未防范返回含有恶意脚本的页面</li></ol><p>注：绕过前端或后台得验证存储在服务器上，其他用户进行访问时，得以执行恶意程序。</p></li><li><p>DOM-Based型XSS</p><p>由于客户端Javascript脚本修改页面DOM结构时（修改文本、重绘、重排）引起浏览器DOM解析所造成的一种漏洞攻击</p><ol><li>用户打开含有恶意的连接</li><li>浏览器在DOM解析时直接使用恶意数据</li><li>用户受到攻击</li></ol></li></ol><h3 id="0x02-XSS防御措施"><a href="#0x02-XSS防御措施" class="headerlink" title="0x02 XSS防御措施"></a>0x02 XSS防御措施</h3><ul><li><p>设置httpOnly</p><p>在客户端无法获取cookies信息 </p></li><li><p>后台过滤</p><ul><li>判断输入格式，只允许特定格式的字符  //对标签进行处理，转成文本化htmlspciachars,特殊字符转义处理。服务端过滤</li><li>收到数据时过滤危险字符</li><li>过滤与转义需前端和服务端配合使用</li></ul><p>对URl和提交表单均进行校验。</p><p>设置一些白明单和黑名单进行过滤一些标记。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      什么是XSS？有哪些分类？如何防御？
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>避免重复提交表单</title>
    <link href="https://comosk.github.io/2020/02/29/%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95/"/>
    <id>https://comosk.github.io/2020/02/29/%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95/</id>
    <published>2020-02-29T03:55:35.000Z</published>
    <updated>2020-02-29T03:57:34.693Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前端控制"><a href="#0x01-前端控制" class="headerlink" title="0x01 前端控制"></a>0x01 前端控制</h3><ol><li>点击提交按钮后，进行页面跳转</li><li>点击之后，提交按钮不可以</li><li>session验证</li></ol><h3 id="0x02-后端控制"><a href="#0x02-后端控制" class="headerlink" title="0x02 后端控制"></a>0x02 后端控制</h3><ol><li>对session的值的验证进行控制，如果session失效，重新生成</li><li>如果没有session则重新生成session</li><li>若是session值相同，则就可以提示相同，请勿重复提交</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      避免重复提交表单方法。
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>CORS（跨域资源共享）</title>
    <link href="https://comosk.github.io/2020/02/29/CORS%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89/"/>
    <id>https://comosk.github.io/2020/02/29/CORS%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89/</id>
    <published>2020-02-29T03:36:39.000Z</published>
    <updated>2020-02-29T03:43:55.891Z</updated>
    
    <content type="html"><![CDATA[<p>通过代理实现跨域过程</p><ul><li>Nignx代理</li><li>Node中间件代理http-proxy-middleware</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);<span class="comment">//express是node中得一个框架</span></span><br><span class="line"><span class="keyword">const</span> { createProxyMiddleware } = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);<span class="comment">//引用中间件http-proxy-middleware</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/api'</span>, createProxyMiddleware({ <span class="attr">target</span>: <span class="string">'http://www.example.org'</span>, <span class="attr">changeOrigin</span>: <span class="literal">true</span> }));<span class="comment">///api请求发起的路径</span></span><br><span class="line">app.listen(<span class="number">3000</span>);<span class="comment">//http目标指向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar</span></span><br></pre></td></tr></tbody></table></figure><p>监听得接收3000端口，然后跳转请求到 <a href="http://www.example.org/api/foo/bar" target="_blank" rel="noopener">http://www.example.org/api/foo/bar</a>   </p><p>因为都是在服务器中，所以不会存在跨域，进行代理跳转。</p><h3 id="0x02-实现跨域请求代理"><a href="#0x02-实现跨域请求代理" class="headerlink" title="0x02 实现跨域请求代理"></a>0x02 实现跨域请求代理</h3><p>node中配置,需要node环境</p><p>安装express   <code>npm install express</code></p><p>安装 http-proxy-middleware    <code>npm install http-proxy-middlerware</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">"http-proxy-middleware"</span>)</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(<span class="string">"/cross-origin"</span>,</span><br><span class="line">       proxy({<span class="attr">target</span>:<span class="string">"http://www.指定跨域地址"</span>})</span><br><span class="line">       )；</span><br><span class="line">app.listen(<span class="number">3000</span>);<span class="comment">//监听端口</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      通过代理实现跨域过程
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>同源策略-跨域请求</title>
    <link href="https://comosk.github.io/2020/02/29/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5-%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
    <id>https://comosk.github.io/2020/02/29/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5-%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</id>
    <published>2020-02-29T03:27:08.000Z</published>
    <updated>2020-02-29T03:30:29.613Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01什么是同源策略？"><a href="#0x01什么是同源策略？" class="headerlink" title="0x01什么是同源策略？"></a>0x01什么是同源策略？</h3><p>同源策略（Same origin policy)是一种约定，它是浏览器最核心也是最基本的安全功能，同源指域名、协议、端口需要保持一致才能进行相互间的访问。</p><p>浏览器采用同源策略，禁止页面加载或执行与自身来源不同的域的任何脚本。换句话说，浏览器禁止的是来自不同源的“docment”或脚本，对当前”docment”读取或设置某些属性。</p><ul><li><code>&lt;script&gt; 、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;</code>这些包含src属性的标签可以加载跨域资源。但浏览器限制了JavaScript的权限，使其不能读、写加载的内容。</li></ul><h3 id="0x02-什么是跨域请求？"><a href="#0x02-什么是跨域请求？" class="headerlink" title="0x02 什么是跨域请求？"></a>0x02 什么是跨域请求？</h3><p>当发起请求的域和请求资源的域不是同一个的时，就是跨域请求。这里的域指的就是协议+域名+端口</p><h3 id="0x03跨域请求实现方案"><a href="#0x03跨域请求实现方案" class="headerlink" title="0x03跨域请求实现方案"></a>0x03跨域请求实现方案</h3><p>虽然安全层面上同源限制是必要的，但有时同源策略会对我们的合理的用途造成影响，为了避免开发的应用受到限制，有很多种方式可以绕开同源策略</p><ul><li><p>通过JSONP可以实现跨域请求处理过程。jquery得ajax提供了jsonp解决方案，请求类型只能是Get</p></li><li><p>通过CORS来实现跨域请求处理过程</p></li><li><p>通过nginx代理来实现跨域请求处理过程</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      当发起请求的域和请求资源的域不是同一个的时，就是跨域请求。
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>会话跟踪</title>
    <link href="https://comosk.github.io/2020/02/29/%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA/"/>
    <id>https://comosk.github.io/2020/02/29/%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA/</id>
    <published>2020-02-29T03:24:24.000Z</published>
    <updated>2020-02-29T03:26:20.740Z</updated>
    
    <content type="html"><![CDATA[<ul><li>session在服务端程序被客户端访问时产生，存在于服务端。</li><li>session具有唯一标识sessionId，在请求中用来重新获得该session.</li><li>session存在后即可向Session中存储数据，这些内容也仅存在于服务端。</li><li>发送客户端的只有sessionid，以后每次客户端发送请求都会携带sessionid。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      sessionid相对于cookie安全，因为只在客户端存储了sessionId。
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>解决eclipse中DDMS无法输出Logcat问题</title>
    <link href="https://comosk.github.io/2020/02/28/%E8%A7%A3%E5%86%B3eclipse%E4%B8%ADDDMS%E6%97%A0%E6%B3%95%E8%BE%93%E5%87%BALogcat%E9%97%AE%E9%A2%98/"/>
    <id>https://comosk.github.io/2020/02/28/%E8%A7%A3%E5%86%B3eclipse%E4%B8%ADDDMS%E6%97%A0%E6%B3%95%E8%BE%93%E5%87%BALogcat%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-28T15:29:18.000Z</published>
    <updated>2020-02-28T15:30:24.343Z</updated>
    
    <content type="html"><![CDATA[<p>原因在于adt版本和android版本不兼容，解决办法进行升级ADT版本，升级至ADT-24.2</p><p><strong>升级步骤：</strong></p><ol><li>下载ADT-24.2，github地址：<a href="https://github.com/khaledev/ADT/releases" target="_blank" rel="noopener">https://github.com/khaledev/ADT/releases</a></li><li>打开eclipse，Help -&gt; Install New Software  -&gt; Add  -&gt; Archive，选择下载的ADT压缩文件</li><li>点击ok，选中Developer Tools选项，一直Accept，下一步操作，安装完成，重启eclipse，再次连接手机，logcat输出日志。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      adt版本和android版本不兼容，解决办法进行升级ADT版本
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全工具" scheme="https://comosk.github.io/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>常见登录认证方式</title>
    <link href="https://comosk.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F/"/>
    <id>https://comosk.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F/</id>
    <published>2020-02-28T15:26:58.000Z</published>
    <updated>2020-02-28T15:28:10.596Z</updated>
    
    <content type="html"><![CDATA[<p>常见认证方式：</p><ol><li>HTTP Basic Auth</li><li>cookie Auth</li><li>Token Auth</li><li>OAuth2.0</li></ol><ul><li><h4 id="HTTP-Basic-Auth"><a href="#HTTP-Basic-Auth" class="headerlink" title="HTTP Basic Auth"></a>HTTP Basic Auth</h4></li></ul><p>最古老的认证方式。客户端在客户端记录用户名和密码，每次请求资源都要带上用户名和密码，后台服务器进行验证，验证通过之后就返回资源，现在基本废弃使用这种方式。尤其是对外提供接口更不能使用。</p><p> <img src="http://p1.pstatp.com/large/pgc-image/9dd5ae22dfe44c5d8d0592e920819caa" alt="网站登录认证方式"> </p><ul><li><h4 id="cookie-Auth"><a href="#cookie-Auth" class="headerlink" title="cookie Auth"></a>cookie Auth</h4><p>客户端创建Cookie对象，服务器端创建Session对象，通过客户端上的Cookie和服务端上的Seesion进行匹配实现状态的管理。默认关闭浏览器cookie会被删除，但可以修改cookie的expire time使在一定时间内有效。Session保存在服务器上，用户量很大会消耗服务器资源。</p><p> <img src="http://p3.pstatp.com/large/pgc-image/074c4fcfc5f94c6e9f78fea7f64ab452" alt="网站登录认证方式"> </p></li><li><h4 id="Token-Auth"><a href="#Token-Auth" class="headerlink" title="Token Auth"></a>Token Auth</h4><p>利用token认证是当前主流的认证方式。当用户进行登录时，服务端生成一串带有用户信息的JSON串，然后通过加密和编码，生成一个无规则的字符串，字符串即token，客户端进行保存好token，每次请求都会带着token，可以放在http的header中，也可以以参数的形式进行传递。服务端得到token之后通过解码解密的到用户信息。如果验证成功之后就会把资源返还给客户端 。</p><p><img src="http://p3.pstatp.com/large/pgc-image/3eca8b370ee74cecb707a21461acbf87" alt="网站登录认证方式"> </p></li></ul><p>token认证优势很多，可以支持跨域、跨平台，由于不用在服务端保存用户信息，可以减轻服务器端的压力，提高性能。针对Token认证有一套标准的JWT(JSON Web token)，目前(.NET、Rubu、Java、Python、PHP)都支持此标准。</p><ul><li><h4 id="OAuth认证"><a href="#OAuth认证" class="headerlink" title="OAuth认证"></a>OAuth认证</h4><p>OAuth认证目前版本为2.0。用户可以凭借令牌，而不是借用用户名和密码来访问特定服务器上的数据。每一个令牌授权给一个特定的第三方系统，在特定的时间内访问特定资源。用户可以借用OAuth授权第三方网站访问储存在另外的服务提供者的某些信息，而非全部内容。</p></li></ul><p>   <img src="E:%5CWeb%E5%AE%89%E5%85%A8%5C%E8%B5%84%E6%96%99%E6%A1%A3%5C%E6%96%87%E6%A1%A3%E9%85%8D%E5%9B%BE%5C5e27c9064ca22c7e54a1d395d679f8b5_r.jpg" alt="5e27c9064ca22c7e54a1d395d679f8b5_r">)<img src="http://p1.pstatp.com/large/pgc-image/1877a1805fbc47308bb664f01e435baf" alt="网站登录认证方式"> </p><p>  例：使用OAuth2.0的微信登录认证</p><p>  Step1. 用户通过授权，获取code</p><p>  Step2. 通过code换取网页授权access_token</p><p>  Step3. 刷新access_token</p><p>  Step4. 拉取用户信息（需scope为snsapi_userinfo)注：snsapi_userinfo获取openid和用户资料（昵称、头像、国、省、城市、性别、权限）</p><p>  当下QQ认证、新浪微博授权登录、支付宝授权登录等等都时使用这种认证方式。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      几种常见网站登录的认证方式……
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2.0协议</title>
    <link href="https://comosk.github.io/2020/02/28/OAuth2-0%E5%8D%8F%E8%AE%AE/"/>
    <id>https://comosk.github.io/2020/02/28/OAuth2-0%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-02-28T15:25:03.000Z</published>
    <updated>2020-02-28T15:26:11.911Z</updated>
    
    <content type="html"><![CDATA[<p>OAuth2.0是用于授权的行业标准协议，允许用户授权第三方移动应用访问他们储存在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容。</p><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>了解几个专用名词</p><ul><li>Third-party application：第三方应用程序(后称“Client”)</li><li>HTTP service：HTTP服务提供商</li><li>Resource Owner:资源所有者(用户)</li><li>User Agent：用户代理(浏览器)</li><li>Authorization server：认证服务器</li><li>Resource server：资源服务器</li></ul><h3 id="0x01-OAuth简单介绍"><a href="#0x01-OAuth简单介绍" class="headerlink" title="0x01 OAuth简单介绍"></a>0x01 OAuth简单介绍</h3><p>OAuth在“第三方应用程序”和”服务提供商”之间设置了一层授权层（authorization layer)。”第三方应用程序”不能直接登录“服务提供商”，只能登录授权层，将第三方应用程序与用户隔开。“第三方应用程序”登录授权层所用的令牌（token)与用户的密码不同。指定授权层的权限范围和有效期是可以指定的。</p><p>“第三方应用程序”登录到授权层，依靠令牌指定的范围和权限进行开放储存资源服务器上的资源。</p><h3 id="0x02-OAuth2-0运行流程"><a href="#0x02-OAuth2-0运行流程" class="headerlink" title="0x02 OAuth2.0运行流程"></a>0x02 OAuth2.0运行流程</h3><p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051203.png" alt="OAuth运行流程"></p><p>A. 用户打开“第三方应用程序”后，”第三方应用程序“要求用户给予授权。</p><p>B. 用户同意给予客户端授权</p><p>C. 客户端得到授权后，向认证服务器进行申请令牌（token)</p><p>D. 认证服务器对客户端进行认证，验证正确后发放令牌</p><p>E. 客户端利用令牌向资源服务器申请获取资源</p><p>F. 资源服务器确认令牌正确后，同意向客户端开发资源</p><p>其中关键的步骤是B，用户如何给客户端进行授权</p><h3 id="0x03-客户端授权模式、"><a href="#0x03-客户端授权模式、" class="headerlink" title="0x03 客户端授权模式、"></a>0x03 客户端授权模式、</h3><p>OAuth2.0指定了四种授权方式</p><ul><li><p>授权码模式（authorization code)</p></li><li><p>简化模式（implicit）</p></li><li><p>密码模式（resource owner password credentials)</p></li><li><p>客户端模式（client credentials)</p><h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><p>授权码模式（authorization code)是功能最完整、流程最严密的授权模式。特点是通过客户端的后台服务器与“服务提供商”的认证服务器进行互动。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2014/bg2014051204.png" alt="授权码模式"> </p></li></ul><p>步骤如下：</p><p>A. 用户访问客户端，客户端将用户端导向认证服务器</p><p>B. 用户选择是否给予客户端授权</p><p>C. 假设用户给予授权，认证服务器将用户导向客户端事先指定的“重定向URL”(redirection URL)，同时附上一个授权码。</p><p>D. 客户端收到授权码，附上早先的”重定向URL“，向认证服务器申请令牌。此步骤对用户不可见。</p><p>E. 认证服务器核对了授权码和重定向URL，确认无误后，向客户端发送访问令牌（Access Token）和更新令牌（refresh token)。</p><p>以上步骤所需参数</p><p>A. 客户端申请认证的URL，包含以下参数：</p><ul><li>response_type：表示授权类型，必选项。值固定为”code”</li><li>client_id：表示客户端的ID，必选项</li><li>redirect_uri：表示重定向URL，可选项</li><li>scope：表示申请的权限范围，可选项</li><li>state：表示当前客户端的状态，可以指定任意值，认证服务器会原封不动的返回这个值</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      OAuth2.0是用于授权的行业标准协议，允许用户授权第三方移动应用访问他们储存在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容。
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS连接过程和中间人攻击</title>
    <link href="https://comosk.github.io/2020/02/28/HTTPS%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
    <id>https://comosk.github.io/2020/02/28/HTTPS%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</id>
    <published>2020-02-28T15:22:52.000Z</published>
    <updated>2020-02-28T15:24:14.556Z</updated>
    
    <content type="html"><![CDATA[<p>大致过程如下：</p><ol><li><p>https请求</p><p>客户端向服务端发送https请求；</p></li><li><p>生成公钥和私钥</p><p>服务端收到请求之后，生成公钥和私钥。</p></li><li><p>返回公钥</p><p>服务端将公钥返回给服务端。公钥里包含很多信息，比如证书的颁发机构、过期时间等</p></li><li><p>客户端验证公钥</p><p>客户端收到公钥之后，验证是否有效。验证证书的颁发机构、过期时间等。如果验证不通过则会抛出异常，显示证书存在问题。如果验证通过，则会生成一个随机值，作为客户端的密钥，然后用服务端的公钥进行加密。</p></li><li><p>发送客户端密钥</p><p>客户端用服务端的公钥加密密钥，然后发送给服务端</p></li><li><p>服务端接收密钥，对称加密内容</p><p>服务端收到经过加密的密钥，然后私钥将其进行解密，得到客户端的密钥，然后服务端将要传输的内容，用客户端得密钥进行对称加密。</p></li><li><p>加密传输</p><p>服务端将经过加密的内容传输给客户端</p></li><li><p>获取加密内容，解密</p><p>客户端获取加密内容后，利用之前生成的随机值作为密钥进行解密，获取到内容。</p></li></ol><p>中间人进行劫持攻击时，关键在于信任中间人的证书。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      HTTPS连接的过程详情……
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>漏洞名称：任意文件上传</title>
    <link href="https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</id>
    <published>2020-02-28T15:20:37.000Z</published>
    <updated>2020-02-28T15:21:39.614Z</updated>
    
    <content type="html"><![CDATA[<p>严重性：高</p><p>要求：文件上传时应该验证文件的类型、文件头信息、大小</p><p>No 1. 漏洞危害</p><p>可以通过恶意脚本文件控制整个网站、甚至控制服务器。恶意文件又被称为WebShell,网页后门。可以查看服务器目录、服务器中的文件、执行系统命令等。</p><p>No  2. 检测是否存在JS绕过攻击</p><ul><li>使用浏览器的插件，删除检测文件后缀的JS检测代码，然后上传文件即可。【注：插件可选择Firebox]</li><li>首先先把文件后缀改成允许上传的，饶过JS的检测，再抓包，再把后缀名改成可执行文件的后缀名即可上传成功。【抓包工具可选择Burp suite】</li></ul><p>No 3. 检测是否存在文件后缀绕过攻击</p><ul><li>服务器代码限制了某些后缀名不允许上传，但是可以允许解析其他文件后缀的。检测httpd.conf的配置文件，查看解析的文件后缀。apache的解析顺序是从右往左解析，直到遇见能解析的文件后缀为止。</li></ul><p>No 4. 检测是否存在文件类型绕过攻击</p><ul><li>通过Burp suite抓取数据包，检测如果上传不同格式的文件时，文件属性是不同的，如果服务端是通过文件类型来判断文件类型的，那么有可能存在被绕过的可能。因为文件类型是通过客户端传递，可以随意修改的。【在PHP语言中存在着一种类似的文件上传漏洞，如果是利用getimagesize()函数来获取图片长、宽、高等信息，如果不是图片就上传不成功，可以将图片和Webshell合并成一个文件，可以使用命令 cat test.php webshell.php &gt; test.php 可以绕过限制】</li></ul><p>No 5. 检测是否存在文件截断绕过攻击</p><ul><li>截断条件：PHP版本小于5.3.4，PHP的magic_quotes_gpc为OFF状态</li><li>截断符 %00，文件上传时，会把截断后的内容放在上传后文件名的第一部分，然后将按时间生成的文件名作为上传文件名的第二部门。【例：如果参数为1.php%00.jpg,那么将会变成1.php，就成功上传了webshell脚本】</li></ul><p>No 6. 检测是否存在竞争条件攻击</p><ul><li>利用检测和删除文件中间的时间，进行生成一个webShell的脚本文件，完成webShell文件的上传。</li></ul><ol><li><p>上传时检查不严。</p><ul><li>利用断点上传工具，来应当对只在客户端进行过滤。</li><li>在服务器端进行黑名单检查时，忽略了大小写。</li><li>在服务器进行白名单检查时，忽略%00的截断符。例只允许上传jpg,就可以构造XXX.exe%00.jpg,在服务端就可以变成xxx.exe</li><li>上传成功后修改后缀名，修改文件后缀名处理不当</li><li>若使用插件时，插件上可能带有文件上传漏洞</li></ul></li><li><p>防范文件上传漏洞</p><ul><li>文件上传目录设置成不可执行</li><li>判断文件类型。结合MIME Type、后缀检测方式。选择白名单</li><li>使用随机数改写文件名和文件路径</li><li>单独设置文件服务器的域名</li></ul><p>防御</p><ul><li>严格检查文件名和文件路径</li><li>服务端使用白名单进行过滤，然后截断符进行检测，HTTP的Content-type进行检测，同时也检测文件上传的大小</li><li>对上传的文件进行重命名。</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      可以通过恶意脚本文件控制整个网站、甚至控制服务器。恶意文件又被称为WebShell,网页后门。可以查看服务器目录、服务器中的文件、执行系统命令等。
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="任意文件上传/下载" scheme="https://comosk.github.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>漏洞名称：任意文件下载/读取</title>
    <link href="https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD-%E8%AF%BB%E5%8F%96/"/>
    <id>https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD-%E8%AF%BB%E5%8F%96/</id>
    <published>2020-02-28T15:18:48.000Z</published>
    <updated>2020-02-28T15:20:12.166Z</updated>
    
    <content type="html"><![CDATA[<p>严重性：High</p><p>漏洞类型：任意文件上传/下载漏洞</p><p>安全要求：文件下载应该验证文件的类型、文件头信息、大小、权限</p><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>某些网站由于业务需求，往往需要提供文件查看或文件下载功能，但是如果对用户查看或下载的文件不做限制，则恶意用户就能查看或下载任意敏感文件。即任意文件下载/读取漏洞。</p><p><strong>引起原因：</strong></p><ul><li>存在读文件的函数</li><li>读取文件的路径用户可控且未校验或校验不严</li><li>输出了文件内容</li></ul><h3 id="0x01-漏洞危害"><a href="#0x01-漏洞危害" class="headerlink" title="0x01 漏洞危害"></a>0x01 漏洞危害</h3><p>下载服务器任意文件，如脚本代码、服务及系统配置文件等，可以得到进一步代码审计，得到更多的可利用漏洞。</p><p><a href="https://shuimugan.com/bug/view?bug_no=62787" target="_blank" rel="noopener">wooyun文件任意下载实例</a></p><h3 id="0x02-任意文件读取"><a href="#0x02-任意文件读取" class="headerlink" title="0x02 任意文件读取"></a>0x02 任意文件读取</h3><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $filename = <span class="string">"test.txt"</span>;</span><br><span class="line">    readfile($filename);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $filename = <span class="string">"test.txt"</span>;</span><br><span class="line"></span><br><span class="line">    $fp = fopen($filename,<span class="string">"r"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">    $data = fread($fp,filesize($filename));</span><br><span class="line">    fclose($fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> $data;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $filename = <span class="string">"test.txt"</span>;</span><br><span class="line">    <span class="keyword">echo</span> file_get_contents($filename);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="0x03-任意文件下载"><a href="#0x03-任意文件下载" class="headerlink" title="0x03 任意文件下载"></a>0x03 任意文件下载</h3><p>直接下载：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.xx.com/a.zip"</span>&gt;</span>Download<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>header()下载</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $filename = <span class="string">"uploads/201607141437284653.jpg"</span>;</span><br><span class="line"></span><br><span class="line">    header(<span class="string">'Content-Type: imgage/jpeg'</span>);</span><br><span class="line">    header(<span class="string">'Content-Disposition: attachment; filename='</span>.$filename);</span><br><span class="line">    header(<span class="string">'Content-Lengh: '</span>.filesize($filename));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="0x04-利用代码"><a href="#0x04-利用代码" class="headerlink" title="0x04 利用代码"></a>0x04 利用代码</h3><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readfile.php?file=/etc/passwd</span><br><span class="line">readfile.php?file=../../../../../../../../etc/passwd</span><br><span class="line">readfile.php?file=../../../../../../../../etc/passwd%<span class="number">00</span></span><br></pre></td></tr></tbody></table></figure><p><strong>Google search</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inurl:<span class="string">"readfile.php?file="</span></span><br><span class="line">inurl:<span class="string">"read.php?filename="</span></span><br><span class="line">inurl:<span class="string">"download.php?file="</span></span><br><span class="line">inurl:<span class="string">"down.php?file="</span></span><br><span class="line">等等...</span><br></pre></td></tr></tbody></table></figure><h3 id="0x05-漏洞挖掘"><a href="#0x05-漏洞挖掘" class="headerlink" title="0x05 漏洞挖掘"></a>0x05 漏洞挖掘</h3><p>利用Google hacking或web漏洞扫描器</p><p>链接形式上：</p><ul><li>readfile.php?file=***.txt</li><li>download.php?file=***.rar</li></ul><p>从参数名看：</p><ul><li>&amp;RealPath=</li><li>&amp;FilePath=</li><li>&amp;filepath=</li><li>&amp;Path=</li><li>&amp;path</li><li>&amp;inputFile=</li><li>&amp;url=</li><li>&amp;urls=</li><li>&amp;Lang=</li><li>&amp;dis=</li><li>&amp;data=</li><li>&amp;readfile=</li><li>&amp;filep=</li><li>&amp;src=</li><li>&amp;menu=</li><li>META-INF</li><li>WEB-INF</li></ul><h3 id="0x06-常见敏感文件"><a href="#0x06-常见敏感文件" class="headerlink" title="0x06 常见敏感文件"></a>0x06 常见敏感文件</h3><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Windows：</span><br><span class="line">   C:\boot.ini  <span class="comment">//查看系统版本</span></span><br><span class="line">   C:\Windows\System32\inetsrv\MetaBase.xml  <span class="comment">//IIS配置文件</span></span><br><span class="line">   C:\Windows\repair\sam  <span class="comment">//存储系统初次安装的密码</span></span><br><span class="line">   C:\Program Files\mysql\my.ini  <span class="comment">//Mysql配置</span></span><br><span class="line">   C:\Program Files\mysql\<span class="keyword">data</span>\mysql\user.MYD  <span class="comment">//Mysql root</span></span><br><span class="line">   C:\Windows\php.ini  <span class="comment">//php配置信息</span></span><br><span class="line">   C:\Windows\my.ini  <span class="comment">//Mysql配置信息</span></span><br><span class="line">   ...</span><br><span class="line">Linux：</span><br><span class="line">   /root/.ssh/authorized_keys</span><br><span class="line">   /root/.ssh/id_rsa</span><br><span class="line">   /root/.ssh/id_ras.keystore</span><br><span class="line">   /root/.ssh/known_hosts</span><br><span class="line">   /etc/passwd</span><br><span class="line">   /etc/shadow</span><br><span class="line">   /etc/my.cnf</span><br><span class="line">   /etc/httpd/conf/httpd.conf</span><br><span class="line">   /root/.bash_history</span><br><span class="line">   /root/.mysql_history</span><br><span class="line">   /proc/self/fd/fd[<span class="number">0</span>-<span class="number">9</span>]*(文件标识符)</span><br><span class="line">   /proc/mounts</span><br><span class="line">   /porc/config.gz</span><br></pre></td></tr></tbody></table></figure><h3 id="0x07-漏洞验证"><a href="#0x07-漏洞验证" class="headerlink" title="0x07 漏洞验证"></a>0x07 漏洞验证</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">• index.php?f=../../../../../../etc/passwd </span><br><span class="line">• index.php?f=../index.php </span><br><span class="line">• index.php?f=ﬁle:<span class="comment">///etc/passwd</span></span><br><span class="line">注：当参数f的参数值为php文件时，若是文件被解析则是文件包含漏洞，</span><br><span class="line">    若显示源码或提示下载则是文件查看与下载漏洞</span><br></pre></td></tr></tbody></table></figure><h3 id="0x08-安全建议"><a href="#0x08-安全建议" class="headerlink" title="0x08 安全建议"></a>0x08 安全建议</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 过滤.(点)，使用户在<span class="selector-tag">url</span>中不能回溯上级目录</span><br><span class="line">* 正则严格判断用户输入参数的格式</span><br><span class="line">* <span class="selector-tag">php</span><span class="selector-class">.ini</span>配置<span class="selector-tag">open_basedir</span>限定文件访问范围</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      某些网站由于业务需求，往往需要提供文件查看或文件下载功能，但是如果对用户查看或下载的文件不做限制，则恶意用户就能查看或下载任意敏感文件。即任意文件下载/读取漏洞。
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="任意文件上传/下载" scheme="https://comosk.github.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
</feed>
