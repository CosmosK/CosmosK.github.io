<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SecNotes</title>
  
  <subtitle>山河远阔 清风徐来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://comosk.github.io/"/>
  <updated>2020-03-01T14:45:18.966Z</updated>
  <id>https://comosk.github.io/</id>
  
  <author>
    <name>л</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DNS域名解析过程详解</title>
    <link href="https://comosk.github.io/2020/03/01/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://comosk.github.io/2020/03/01/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-03-01T14:43:49.000Z</published>
    <updated>2020-03-01T14:45:18.966Z</updated>
    
    <content type="html"><![CDATA[<p>​    信息收集对于渗透测试来说是重要的第一步，所以当然离不开whois,whois是用来查看域名的IP以及所有者的信息的传输协议。可以查看注册的域名所有人等。上面可以进行爆破邮箱、社工、域名劫持等方法攻击，下面详细讲解DNS解析过程。</p><p><img src="https://images2015.cnblogs.com/blog/464291/201707/464291-20170703113844956-354755333.jpg" alt="img"> </p><h3 id="0x01-根域"><a href="#0x01-根域" class="headerlink" title="0x01 根域"></a>0x01 根域</h3><p>其实就是所谓的“.”，所有网站的完整形式都有最后的一个点。即<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>. 。但习惯省略了后面的点。</p><p>域名是分级的，所以域名解析也是分级的，本地DNS服务器不存在我们查找的域名IP地址时，下一步就会直接向根域名DNS服务器进行发出解析请求。</p><p>根域服务器只有13个IP地址，但机器不仅仅只有13个。IP地址是借助传播的技术的，所以我们可以在全球都可以访问到这些IP的镜像站点。</p><p>kali liunx提供一个dig命令来查看相关信息：dig 指定站点</p><h3 id="0x02-域的划分"><a href="#0x02-域的划分" class="headerlink" title="0x02 域的划分"></a>0x02 域的划分</h3><p>根域下来就是一级域也叫顶级域</p><blockquote><p>两种划分方式：按行业性质和按国家</p><ul><li>按行业：.com  .org ……</li><li>按国家：.cn   .jp  .us</li></ul></blockquote><p>每个域都有自己的域名服务器，也叫权威域名服务器</p><p>一级域名之后还有二级域名、三级域名。而且只要买了一个顶级域名，搭建了自己BIND服务器注册测到互联网中，就可以随意的多加几个域了。</p><h3 id="0x03-域名服务器"><a href="#0x03-域名服务器" class="headerlink" title="0x03 域名服务器"></a>0x03 域名服务器</h3><p>提供域名解析的服务器，上面的记录可以是A(address)记录，NS(nameserver)记录，MX(mail)，CNAME等。</p><ul><li><p>A记录</p><p>又称IP指向。在此设置子域名并且指向自己的目标主机地址上，从而实现通过域名找到都武器。注：指向目标主机地址，只能使用IP地址</p><blockquote><ul><li>泛域名解析：指将该域名所有未指定的子域名都指向一个地址。在主机名：*| 类型：A|IP地址/主机名：IP地址</li><li>SLB（负载均衡Server load balancing）：指在一系列资源上动态分布网络负载。相同子域名有多个目标地址时，即是轮询，达到SLB，但需要虚拟主机服务商支持</li></ul></blockquote></li><li><p>CNAME</p><p>通常称为别名指向。为自己的主机设置一个别名，例test.com，用来指向<a href="http://www.abcd.com，以后就可以用test.com来代替访问www.abcd.com了。" target="_blank" rel="noopener">www.abcd.com，以后就可以用test.com来代替访问www.abcd.com了。</a></p><p>CNAME中目标地址只能使用主机名，不能使用IP地址，主机名前面不能有任何前缀如https://</p><div class="note info">            <p>注：A记录优于CNAME记录。即两者同时存在，CNAME不生效。</p>          </div></li><li><p>MX记录</p><p>邮件交换记录。用于以该域名为结尾的电子邮件指向对应的邮件服务器进行处理。例邮件是以域名testabcd.com结尾的，那么管理界面添加该域名的MX记录来处理所有@testabcd.com结尾的邮件。</p><blockquote><p>MX记录可以使用主机或IP地址。可以设置优先级实现主辅服务器设置，优先级中数字越小，优先级越高。相同的数字实现负载均衡。</p><p>如果在“主机名”中填入子域名则此MX记录只对该子域名生效。</p><p>当域名的MX记录有多个目标地址且优先级相同时，表示轮循，可以达到负载均衡的目的</p></blockquote></li><li><p>NS记录</p><blockquote><p>解析服务器记录。用来表明由哪台服务器对该域名进行解析。 只对子域名生效。 </p></blockquote><div class="note info">            <p>注：NS记录高于A记录。</p>          </div><p>注：TTL值TTL值全称是“生存时间（ Time To Live)” ，简单的说它表示DNS记录在 DNS服务器上缓存时间 </p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    信息收集对于渗透测试来说是重要的第一步，所以当然离不开whois,whois是用来查看域名的IP以及所有者的信息的传输协议。可以查看注册的域名所有人等。上面可以进行爆破邮箱、社工、域名劫持等方法攻击，下面详细讲解DNS解析过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="DNS解析" scheme="https://comosk.github.io/tags/DNS%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>绕过CDN查看真实IP方法</title>
    <link href="https://comosk.github.io/2020/03/01/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E7%9C%8B%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95/"/>
    <id>https://comosk.github.io/2020/03/01/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E7%9C%8B%E7%9C%9F%E5%AE%9EIP%E6%96%B9%E6%B3%95/</id>
    <published>2020-03-01T13:45:54.000Z</published>
    <updated>2020-03-01T13:51:01.434Z</updated>
    
    <content type="html"><![CDATA[<p>绕过CND查看网站真实IP的一些方法</p><h5 id="0x01-验证是否存在CDN最简单的方法"><a href="#0x01-验证是否存在CDN最简单的方法" class="headerlink" title="0x01. 验证是否存在CDN最简单的方法"></a>0x01. 验证是否存在CDN最简单的方法</h5><blockquote><p>通过在线的多地ping，即通过每个地区ping的结果的得到IP</p><p>看这些IP是否一直，如果都是一样的，极大可能不存在CDN，但不绝对</p><p>如果这些IP大多都不太一样，或者规律性很强，可以尝试查询这些IP的归属地，判断是否都存在CDN</p></blockquote><h5 id="0x02-验证IP和域名是否真实对应最简单的办法"><a href="#0x02-验证IP和域名是否真实对应最简单的办法" class="headerlink" title="0x02. 验证IP和域名是否真实对应最简单的办法"></a>0x02. 验证IP和域名是否真实对应最简单的办法</h5><blockquote><p>修改本地hosts文件，强行将域名与IP解析对应</p><p>然后访问域名页面是否发生变化</p><ol><li><p><code>ping</code></p><p>假设存在CDN</p><p>ping www.域名.com 是不通的</p><p>尝试 ping 域名.com</p><p>很多厂商可能让www使用CDN，空域名不使用CDN缓存</p><p>即直接ping 域名，可能得到真实IP</p></li><li><p>分站域名</p><p>很多网站主站的访问量比较大，所以主站都是挂CDN，但分站不一定使用CDN</p><p>这个时候可以尝试去查看相应分站IP。推荐<code>Zoomeye.org</code>，<code>shodan.io</code>，<code>fofa</code>。都可以选择</p></li><li><p>国外访问</p><p>国内的CDN往往只针对国内用户访问加速，所以国外就不一定。即使用国外代理访问就能查看真实的IP了</p><p>利用国外的DNS解析，就有可能得到真实IP</p></li></ol></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      有些网站的IP进行使用了CDN（内容分发网络），导致IP随着不同地方的访问，所得到的IP地址是不同的，这个时候我你们怎么绕过CDN查看真实IP地址
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://comosk.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="信息收集" scheme="https://comosk.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试之信息收集【2020.3.1记】</title>
    <link href="https://comosk.github.io/2020/03/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E3%80%902020-3-1%E8%AE%B0%E3%80%91/"/>
    <id>https://comosk.github.io/2020/03/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E3%80%902020-3-1%E8%AE%B0%E3%80%91/</id>
    <published>2020-03-01T13:42:57.000Z</published>
    <updated>2020-03-01T13:45:07.308Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Web信息收集"><a href="#1-Web信息收集" class="headerlink" title="1. Web信息收集"></a>1. Web信息收集</h3><h4 id="0x01-网站源码脚本"><a href="#0x01-网站源码脚本" class="headerlink" title="0x01 网站源码脚本"></a>0x01 网站源码脚本</h4><blockquote><p>伪静态 :不是真正的静态格式文件 </p><p>利用F12查看更多的信息，查看相应的开发语言，如果简单的一次看不出来，可以多发送几次数据包，然后进行目录扫描的时候，例如<code>御剑</code>，选择相应的字典类型。</p><p>F12进入开发者模式，在network中多提交地址访问抓包分析，在requset和response来回的数据包中去发现更多的信息。</p></blockquote><h4 id="0x02-Web指纹识别"><a href="#0x02-Web指纹识别" class="headerlink" title="0x02. Web指纹识别"></a>0x02. Web指纹识别</h4><blockquote><p>Web应用是利用cms进行搭建的，进行CMS进行相应的识别后，可以查看更多的信息</p><p>平台：搜索引擎去搜索Web指纹识别</p><p>工具：<code>cmsmap</code> <code>御剑cms</code></p></blockquote><h4 id="0x03-网站对应数据库"><a href="#0x03-网站对应数据库" class="headerlink" title="0x03. 网站对应数据库"></a>0x03. 网站对应数据库</h4><blockquote><p>常用的数据库组合匹配，php:mysql aspx:mssql asp:access |jsp:mysql/oracle py:mongodb</p><p>端口扫描判断<code>zenmap</code> <code>masscan</code>：内网服务器方法失效</p><p>常见数据库端口：mysql:3306 mssql:1433 oracle:1521,详细见<a href="https://www.cnblogs.com/botoo/p/10475402.html" target="_blank" rel="noopener">端口渗透总结</a></p></blockquote><h4 id="0x04-网站搭建平台"><a href="#0x04-网站搭建平台" class="headerlink" title="0x04. 网站搭建平台"></a>0x04. 网站搭建平台</h4><blockquote><p>查看元素或审查元素抓包获取</p></blockquote><h4 id="0x05-服务器操作系统"><a href="#0x05-服务器操作系统" class="headerlink" title="0x05. 服务器操作系统"></a>0x05. 服务器操作系统</h4><blockquote><p>大小写判断Windows大小写不敏感，liunx相反</p></blockquote><h4 id="0x06-robots协议"><a href="#0x06-robots协议" class="headerlink" title="0x06. robots协议"></a>0x06. robots协议</h4><blockquote><p>写给搜索引擎看的，搜索殷勤去爬行数据时，有选择的爬行。</p><p>查看方法直地址/robots.txt获取</p></blockquote><h3 id="2-端口信息收集"><a href="#2-端口信息收集" class="headerlink" title="2. 端口信息收集"></a>2. 端口信息收集</h3><h4 id="0x01-服务协议对应"><a href="#0x01-服务协议对应" class="headerlink" title="0x01. 服务协议对应"></a>0x01. 服务协议对应</h4><blockquote><p><a href="https://www.cnblogs.com/botoo/p/10475402.html" target="_blank" rel="noopener">端口渗透总结</a></p></blockquote><h4 id="0x02-Web端口对应"><a href="#0x02-Web端口对应" class="headerlink" title="0x02. Web端口对应"></a>0x02. Web端口对应</h4><blockquote><p>搜索引擎去查看打开8080端口的，inurl:8080，如果不加8080和加8080是不同的目标，这就是两个目标</p></blockquote><h3 id="3-目录信息收集"><a href="#3-目录信息收集" class="headerlink" title="3. 目录信息收集"></a>3. 目录信息收集</h3><h4 id="0x01-敏感文件"><a href="#0x01-敏感文件" class="headerlink" title="0x01. 敏感文件"></a>0x01. 敏感文件</h4><blockquote><p>工具：<code>WebPathBrute[御剑实战靶场]</code></p><p>备份文件、数据库备份文件、源码备份文件等</p><p>说明文件、源码说明、其他说明等</p></blockquote><h4 id="0x02-目录站点"><a href="#0x02-目录站点" class="headerlink" title="0x02. 目录站点"></a>0x02. 目录站点</h4><blockquote><p>不同的搭建不同的地址</p></blockquote><h4 id="0x03-爬行目录"><a href="#0x03-爬行目录" class="headerlink" title="0x03. 爬行目录"></a>0x03. 爬行目录</h4><blockquote><p>扫描工具对其进行扫描，其中可能包括后台地址</p><p>工具：layer子域名挖掘机。或kali命令：dirb</p></blockquote><h4 id="0x04-扫描目录"><a href="#0x04-扫描目录" class="headerlink" title="0x04. 扫描目录"></a>0x04. 扫描目录</h4><blockquote><p>通过字典扫描可能存在的页面，主要扫描后台和上传目录</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      渗透测试开始时要更多更全面的进行信息的收集，包括Web信息收集，端口信息收集，目录信息收集……
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://comosk.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="信息收集" scheme="https://comosk.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Web安全渗透测试常见下手方式</title>
    <link href="https://comosk.github.io/2020/03/01/Web%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E4%B8%8B%E6%89%8B%E6%96%B9%E5%BC%8F/"/>
    <id>https://comosk.github.io/2020/03/01/Web%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E4%B8%8B%E6%89%8B%E6%96%B9%E5%BC%8F/</id>
    <published>2020-03-01T13:31:26.000Z</published>
    <updated>2020-03-01T13:34:54.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-基于Web的安全漏洞的渗透✒️"><a href="#0x01-基于Web的安全漏洞的渗透✒️" class="headerlink" title="0x01 基于Web的安全漏洞的渗透✒️"></a>0x01 基于Web的安全漏洞的渗透✒️</h3><blockquote><ol><li>主要是针对Web应用进行安全测试，从Web下手</li><li>检测有没有SQL注入，XSS等漏洞，然后针对漏洞进行攻击</li></ol></blockquote><h3 id="0x02-基于Web的CMS漏洞的渗透👶"><a href="#0x02-基于Web的CMS漏洞的渗透👶" class="headerlink" title="0x02 基于Web的CMS漏洞的渗透👶"></a>0x02 基于Web的CMS漏洞的渗透👶</h3><blockquote><ol><li>通过对CMS系统的一个指纹识别，去查看使用的第三方软件和服务器，开发语言之类的信息</li><li>主要有两种方式，方式一:平台，通过搜索引擎<code>搜索Web指纹识别</code></li><li>另一种方式：利用工具<code>cmsmap</code> <code>御剑CMS</code></li></ol></blockquote><h3 id="0x03-基于Web和端口结合的渗透💙"><a href="#0x03-基于Web和端口结合的渗透💙" class="headerlink" title="0x03 基于Web和端口结合的渗透💙"></a>0x03 基于Web和端口结合的渗透💙</h3><blockquote><ol><li>对域名地址无从下手，选择利用端口进行入手</li><li>采用工具<code>zenmap</code>或<code>nmap</code>进行全部端口的扫描探针</li><li>扫描端口结果后在域名后面进行：域名/IP+端口号</li><li>查看有几个站点，如果不是站点，可以进行目录扫描</li></ol></blockquote><blockquote><p>意义：在于端口这个地方也是一个机会。</p></blockquote><h3 id="0x04-基于Web目录结构上的渗透🗂"><a href="#0x04-基于Web目录结构上的渗透🗂" class="headerlink" title="0x04 基于Web目录结构上的渗透🗂"></a>0x04 基于Web目录结构上的渗透🗂</h3><blockquote><ol><li>管理员之类的忽视的一个问题，设置不当</li><li>网站其他目录可能也是一个程序应用</li><li>利用爬虫进行爬行进行目录扫描，相应工具<code>御剑</code> <code>dirb</code></li></ol></blockquote><h3 id="0x05-基于Web域名结构上的渗透⛹️‍♀️"><a href="#0x05-基于Web域名结构上的渗透⛹️‍♀️" class="headerlink" title="0x05 基于Web域名结构上的渗透⛹️‍♀️"></a>0x05 基于Web域名结构上的渗透⛹️‍♀️</h3><blockquote><ol><li>如果域名上无从下手的话，可以从子域名上进行入手</li><li>可以寻找相应的子域名和二级域名，利用工具<code>layer子域名挖掘机</code></li><li><code>layer子域名挖掘机</code>原理是通过字典-&gt;枚举接口-&gt;进行前缀名的拼接。</li><li>查看是否是同一IP最好，如果不是同一IP可以查看是否是同一网段，从内网下手</li><li>利用搜索引擎进行查看子域名，<code>site:baidu.com</code>，<code>inurl:baidu.com</code>接下来利用脚本去爬行域名结果</li><li>工具有的利用字典，有的利用爆破</li></ol></blockquote><h3 id="0x06-基于中间件平台漏洞的渗透👤"><a href="#0x06-基于中间件平台漏洞的渗透👤" class="headerlink" title="0x06 基于中间件平台漏洞的渗透👤"></a>0x06 基于中间件平台漏洞的渗透👤</h3><blockquote><ol><li>类似于<code>IIS</code> <code>tomcat</code> <code>apache</code> <code>Nginx</code>等中间件常见漏洞，细看常见Web中间件常见漏洞总结</li><li>发现这些漏洞，一些扫描工具进行一些探针，或者是发现这些服务器，信息收集的时候去搜索相应的漏洞。</li><li><code>IIS</code>利用工具<code>Netsparker</code>去扫描</li></ol></blockquote><h3 id="0x07-基于第三方软件漏洞的渗透🤙"><a href="#0x07-基于第三方软件漏洞的渗透🤙" class="headerlink" title="0x07 基于第三方软件漏洞的渗透🤙"></a>0x07 基于第三方软件漏洞的渗透🤙</h3><blockquote><ol><li>查看相应IP地址，利用ping:域名，得到IP地址</li><li>利用端口扫描，利用协议去查看哪些服务，第三方软件，服务一搬利用端口</li><li>利用端口进行访问，查看服务器软件，搜索相应的漏洞，查看攻击方式</li></ol></blockquote><blockquote><p>利用端口扫描然后查找第三方软件，然后搜索第三方软件的漏洞，然后进行尝试攻吉</p></blockquote><h3 id="0x08-基于服务器系统漏洞的渗透🗡"><a href="#0x08-基于服务器系统漏洞的渗透🗡" class="headerlink" title="0x08 基于服务器系统漏洞的渗透🗡"></a>0x08 基于服务器系统漏洞的渗透🗡</h3><blockquote><ol><li>针对系统的漏洞利用相对专业的系统扫描工具，例<code>openvs</code> <code>nessus</code></li><li>注：经常进行更新nessus，使用相应的插件plugins</li><li>然后选择常用的advanced Scan进行扫描，Target可以使用IP地址</li><li>查看扫描结果查看漏洞介绍，进行相应的漏洞利用</li></ol></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      针对Web安全渗透测试常见的下手方式，在Web应用无从下手的时候，也可以选择Web的CMS漏洞，端口方面，域名结构，目录等方面进行下手。
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://comosk.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>XSS攻击方式及防御措施</title>
    <link href="https://comosk.github.io/2020/02/29/XSS%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD/"/>
    <id>https://comosk.github.io/2020/02/29/XSS%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD/</id>
    <published>2020-02-29T03:58:27.000Z</published>
    <updated>2020-02-29T04:00:40.839Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前端XSS攻击分类"><a href="#0x01-前端XSS攻击分类" class="headerlink" title="0x01 前端XSS攻击分类"></a>0x01 前端XSS攻击分类</h3><ul><li><p>什么是XSS?</p><p>XSS允许恶意的Web用户将代码植入到提供给其他用户使用的页面中</p><ol><li>攻击者往网页里注入恶意脚本代码</li><li>当用户访问包含恶意代码的网页时</li><li>通过恶意脚本攻击者可以获取和控制用户信息</li></ol></li><li><p>XSS分类</p><ol><li><p>反射型（非持久型）XSS</p><p>​    诱导用户点击带有恶意脚本的URL，而服务器直接使用了恶意脚本并返回了结果页，从而导致恶意代码在浏览器执行。</p><p>​    点击恶意URL，导致恶意代码的执行。</p></li></ol></li></ul><p>  ​    src=“js”发送一个ajax请求，获取信息。</p><p>  注：防止XSS获取Cookie值得方式，去设置一个httponly标志，防止客户端获取cookie。</p><ol><li><p>存储型（持久型）XSS</p><p>将恶意代码上传或存储到了漏洞服务器上，用户访问页面时，页面中包含恶意脚本。</p></li><li><p>攻击者将恶意代码上传到服务器</p><ol><li>访问包含恶意脚本的页面</li></ol></li><li><p>服务器读取恶意数据且直接使用</p><ol><li>服务器未防范返回含有恶意脚本的页面</li></ol><p>注：绕过前端或后台得验证存储在服务器上，其他用户进行访问时，得以执行恶意程序。</p></li><li><p>DOM-Based型XSS</p><p>由于客户端Javascript脚本修改页面DOM结构时（修改文本、重绘、重排）引起浏览器DOM解析所造成的一种漏洞攻击</p><ol><li>用户打开含有恶意的连接</li><li>浏览器在DOM解析时直接使用恶意数据</li><li>用户受到攻击</li></ol></li></ol><h3 id="0x02-XSS防御措施"><a href="#0x02-XSS防御措施" class="headerlink" title="0x02 XSS防御措施"></a>0x02 XSS防御措施</h3><ul><li><p>设置httpOnly</p><p>在客户端无法获取cookies信息 </p></li><li><p>后台过滤</p><ul><li>判断输入格式，只允许特定格式的字符  //对标签进行处理，转成文本化htmlspciachars,特殊字符转义处理。服务端过滤</li><li>收到数据时过滤危险字符</li><li>过滤与转义需前端和服务端配合使用</li></ul><p>对URl和提交表单均进行校验。</p><p>设置一些白明单和黑名单进行过滤一些标记。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      什么是XSS？有哪些分类？如何防御？
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>避免重复提交表单</title>
    <link href="https://comosk.github.io/2020/02/29/%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95/"/>
    <id>https://comosk.github.io/2020/02/29/%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95/</id>
    <published>2020-02-29T03:55:35.000Z</published>
    <updated>2020-02-29T03:57:34.693Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前端控制"><a href="#0x01-前端控制" class="headerlink" title="0x01 前端控制"></a>0x01 前端控制</h3><ol><li>点击提交按钮后，进行页面跳转</li><li>点击之后，提交按钮不可以</li><li>session验证</li></ol><h3 id="0x02-后端控制"><a href="#0x02-后端控制" class="headerlink" title="0x02 后端控制"></a>0x02 后端控制</h3><ol><li>对session的值的验证进行控制，如果session失效，重新生成</li><li>如果没有session则重新生成session</li><li>若是session值相同，则就可以提示相同，请勿重复提交</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      避免重复提交表单方法。
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>CORS（跨域资源共享）</title>
    <link href="https://comosk.github.io/2020/02/29/CORS%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89/"/>
    <id>https://comosk.github.io/2020/02/29/CORS%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89/</id>
    <published>2020-02-29T03:36:39.000Z</published>
    <updated>2020-02-29T03:43:55.891Z</updated>
    
    <content type="html"><![CDATA[<p>通过代理实现跨域过程</p><ul><li>Nignx代理</li><li>Node中间件代理http-proxy-middleware</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);<span class="comment">//express是node中得一个框架</span></span><br><span class="line"><span class="keyword">const</span> { createProxyMiddleware } = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);<span class="comment">//引用中间件http-proxy-middleware</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/api'</span>, createProxyMiddleware({ <span class="attr">target</span>: <span class="string">'http://www.example.org'</span>, <span class="attr">changeOrigin</span>: <span class="literal">true</span> }));<span class="comment">///api请求发起的路径</span></span><br><span class="line">app.listen(<span class="number">3000</span>);<span class="comment">//http目标指向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar</span></span><br></pre></td></tr></tbody></table></figure><p>监听得接收3000端口，然后跳转请求到 <a href="http://www.example.org/api/foo/bar" target="_blank" rel="noopener">http://www.example.org/api/foo/bar</a>   </p><p>因为都是在服务器中，所以不会存在跨域，进行代理跳转。</p><h3 id="0x02-实现跨域请求代理"><a href="#0x02-实现跨域请求代理" class="headerlink" title="0x02 实现跨域请求代理"></a>0x02 实现跨域请求代理</h3><p>node中配置,需要node环境</p><p>安装express   <code>npm install express</code></p><p>安装 http-proxy-middleware    <code>npm install http-proxy-middlerware</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">"http-proxy-middleware"</span>)</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(<span class="string">"/cross-origin"</span>,</span><br><span class="line">       proxy({<span class="attr">target</span>:<span class="string">"http://www.指定跨域地址"</span>})</span><br><span class="line">       )；</span><br><span class="line">app.listen(<span class="number">3000</span>);<span class="comment">//监听端口</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      通过代理实现跨域过程
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>同源策略-跨域请求</title>
    <link href="https://comosk.github.io/2020/02/29/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5-%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
    <id>https://comosk.github.io/2020/02/29/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5-%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</id>
    <published>2020-02-29T03:27:08.000Z</published>
    <updated>2020-02-29T03:30:29.613Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01什么是同源策略？"><a href="#0x01什么是同源策略？" class="headerlink" title="0x01什么是同源策略？"></a>0x01什么是同源策略？</h3><p>同源策略（Same origin policy)是一种约定，它是浏览器最核心也是最基本的安全功能，同源指域名、协议、端口需要保持一致才能进行相互间的访问。</p><p>浏览器采用同源策略，禁止页面加载或执行与自身来源不同的域的任何脚本。换句话说，浏览器禁止的是来自不同源的“docment”或脚本，对当前”docment”读取或设置某些属性。</p><ul><li><code>&lt;script&gt; 、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;</code>这些包含src属性的标签可以加载跨域资源。但浏览器限制了JavaScript的权限，使其不能读、写加载的内容。</li></ul><h3 id="0x02-什么是跨域请求？"><a href="#0x02-什么是跨域请求？" class="headerlink" title="0x02 什么是跨域请求？"></a>0x02 什么是跨域请求？</h3><p>当发起请求的域和请求资源的域不是同一个的时，就是跨域请求。这里的域指的就是协议+域名+端口</p><h3 id="0x03跨域请求实现方案"><a href="#0x03跨域请求实现方案" class="headerlink" title="0x03跨域请求实现方案"></a>0x03跨域请求实现方案</h3><p>虽然安全层面上同源限制是必要的，但有时同源策略会对我们的合理的用途造成影响，为了避免开发的应用受到限制，有很多种方式可以绕开同源策略</p><ul><li><p>通过JSONP可以实现跨域请求处理过程。jquery得ajax提供了jsonp解决方案，请求类型只能是Get</p></li><li><p>通过CORS来实现跨域请求处理过程</p></li><li><p>通过nginx代理来实现跨域请求处理过程</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      当发起请求的域和请求资源的域不是同一个的时，就是跨域请求。
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>会话跟踪</title>
    <link href="https://comosk.github.io/2020/02/29/%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA/"/>
    <id>https://comosk.github.io/2020/02/29/%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA/</id>
    <published>2020-02-29T03:24:24.000Z</published>
    <updated>2020-02-29T03:26:20.740Z</updated>
    
    <content type="html"><![CDATA[<ul><li>session在服务端程序被客户端访问时产生，存在于服务端。</li><li>session具有唯一标识sessionId，在请求中用来重新获得该session.</li><li>session存在后即可向Session中存储数据，这些内容也仅存在于服务端。</li><li>发送客户端的只有sessionid，以后每次客户端发送请求都会携带sessionid。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      sessionid相对于cookie安全，因为只在客户端存储了sessionId。
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>解决eclipse中DDMS无法输出Logcat问题</title>
    <link href="https://comosk.github.io/2020/02/28/%E8%A7%A3%E5%86%B3eclipse%E4%B8%ADDDMS%E6%97%A0%E6%B3%95%E8%BE%93%E5%87%BALogcat%E9%97%AE%E9%A2%98/"/>
    <id>https://comosk.github.io/2020/02/28/%E8%A7%A3%E5%86%B3eclipse%E4%B8%ADDDMS%E6%97%A0%E6%B3%95%E8%BE%93%E5%87%BALogcat%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-28T15:29:18.000Z</published>
    <updated>2020-02-28T15:30:24.343Z</updated>
    
    <content type="html"><![CDATA[<p>原因在于adt版本和android版本不兼容，解决办法进行升级ADT版本，升级至ADT-24.2</p><p><strong>升级步骤：</strong></p><ol><li>下载ADT-24.2，github地址：<a href="https://github.com/khaledev/ADT/releases" target="_blank" rel="noopener">https://github.com/khaledev/ADT/releases</a></li><li>打开eclipse，Help -&gt; Install New Software  -&gt; Add  -&gt; Archive，选择下载的ADT压缩文件</li><li>点击ok，选中Developer Tools选项，一直Accept，下一步操作，安装完成，重启eclipse，再次连接手机，logcat输出日志。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      adt版本和android版本不兼容，解决办法进行升级ADT版本
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全工具" scheme="https://comosk.github.io/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>常见登录认证方式</title>
    <link href="https://comosk.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F/"/>
    <id>https://comosk.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F/</id>
    <published>2020-02-28T15:26:58.000Z</published>
    <updated>2020-02-28T15:28:10.596Z</updated>
    
    <content type="html"><![CDATA[<p>常见认证方式：</p><ol><li>HTTP Basic Auth</li><li>cookie Auth</li><li>Token Auth</li><li>OAuth2.0</li></ol><ul><li><h4 id="HTTP-Basic-Auth"><a href="#HTTP-Basic-Auth" class="headerlink" title="HTTP Basic Auth"></a>HTTP Basic Auth</h4></li></ul><p>最古老的认证方式。客户端在客户端记录用户名和密码，每次请求资源都要带上用户名和密码，后台服务器进行验证，验证通过之后就返回资源，现在基本废弃使用这种方式。尤其是对外提供接口更不能使用。</p><p> <img src="http://p1.pstatp.com/large/pgc-image/9dd5ae22dfe44c5d8d0592e920819caa" alt="网站登录认证方式"> </p><ul><li><h4 id="cookie-Auth"><a href="#cookie-Auth" class="headerlink" title="cookie Auth"></a>cookie Auth</h4><p>客户端创建Cookie对象，服务器端创建Session对象，通过客户端上的Cookie和服务端上的Seesion进行匹配实现状态的管理。默认关闭浏览器cookie会被删除，但可以修改cookie的expire time使在一定时间内有效。Session保存在服务器上，用户量很大会消耗服务器资源。</p><p> <img src="http://p3.pstatp.com/large/pgc-image/074c4fcfc5f94c6e9f78fea7f64ab452" alt="网站登录认证方式"> </p></li><li><h4 id="Token-Auth"><a href="#Token-Auth" class="headerlink" title="Token Auth"></a>Token Auth</h4><p>利用token认证是当前主流的认证方式。当用户进行登录时，服务端生成一串带有用户信息的JSON串，然后通过加密和编码，生成一个无规则的字符串，字符串即token，客户端进行保存好token，每次请求都会带着token，可以放在http的header中，也可以以参数的形式进行传递。服务端得到token之后通过解码解密的到用户信息。如果验证成功之后就会把资源返还给客户端 。</p><p><img src="http://p3.pstatp.com/large/pgc-image/3eca8b370ee74cecb707a21461acbf87" alt="网站登录认证方式"> </p></li></ul><p>token认证优势很多，可以支持跨域、跨平台，由于不用在服务端保存用户信息，可以减轻服务器端的压力，提高性能。针对Token认证有一套标准的JWT(JSON Web token)，目前(.NET、Rubu、Java、Python、PHP)都支持此标准。</p><ul><li><h4 id="OAuth认证"><a href="#OAuth认证" class="headerlink" title="OAuth认证"></a>OAuth认证</h4><p>OAuth认证目前版本为2.0。用户可以凭借令牌，而不是借用用户名和密码来访问特定服务器上的数据。每一个令牌授权给一个特定的第三方系统，在特定的时间内访问特定资源。用户可以借用OAuth授权第三方网站访问储存在另外的服务提供者的某些信息，而非全部内容。</p></li></ul><p>   <img src="E:%5CWeb%E5%AE%89%E5%85%A8%5C%E8%B5%84%E6%96%99%E6%A1%A3%5C%E6%96%87%E6%A1%A3%E9%85%8D%E5%9B%BE%5C5e27c9064ca22c7e54a1d395d679f8b5_r.jpg" alt="5e27c9064ca22c7e54a1d395d679f8b5_r">)<img src="http://p1.pstatp.com/large/pgc-image/1877a1805fbc47308bb664f01e435baf" alt="网站登录认证方式"> </p><p>  例：使用OAuth2.0的微信登录认证</p><p>  Step1. 用户通过授权，获取code</p><p>  Step2. 通过code换取网页授权access_token</p><p>  Step3. 刷新access_token</p><p>  Step4. 拉取用户信息（需scope为snsapi_userinfo)注：snsapi_userinfo获取openid和用户资料（昵称、头像、国、省、城市、性别、权限）</p><p>  当下QQ认证、新浪微博授权登录、支付宝授权登录等等都时使用这种认证方式。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      几种常见网站登录的认证方式……
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2.0协议</title>
    <link href="https://comosk.github.io/2020/02/28/OAuth2-0%E5%8D%8F%E8%AE%AE/"/>
    <id>https://comosk.github.io/2020/02/28/OAuth2-0%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-02-28T15:25:03.000Z</published>
    <updated>2020-02-28T15:26:11.911Z</updated>
    
    <content type="html"><![CDATA[<p>OAuth2.0是用于授权的行业标准协议，允许用户授权第三方移动应用访问他们储存在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容。</p><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>了解几个专用名词</p><ul><li>Third-party application：第三方应用程序(后称“Client”)</li><li>HTTP service：HTTP服务提供商</li><li>Resource Owner:资源所有者(用户)</li><li>User Agent：用户代理(浏览器)</li><li>Authorization server：认证服务器</li><li>Resource server：资源服务器</li></ul><h3 id="0x01-OAuth简单介绍"><a href="#0x01-OAuth简单介绍" class="headerlink" title="0x01 OAuth简单介绍"></a>0x01 OAuth简单介绍</h3><p>OAuth在“第三方应用程序”和”服务提供商”之间设置了一层授权层（authorization layer)。”第三方应用程序”不能直接登录“服务提供商”，只能登录授权层，将第三方应用程序与用户隔开。“第三方应用程序”登录授权层所用的令牌（token)与用户的密码不同。指定授权层的权限范围和有效期是可以指定的。</p><p>“第三方应用程序”登录到授权层，依靠令牌指定的范围和权限进行开放储存资源服务器上的资源。</p><h3 id="0x02-OAuth2-0运行流程"><a href="#0x02-OAuth2-0运行流程" class="headerlink" title="0x02 OAuth2.0运行流程"></a>0x02 OAuth2.0运行流程</h3><p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051203.png" alt="OAuth运行流程"></p><p>A. 用户打开“第三方应用程序”后，”第三方应用程序“要求用户给予授权。</p><p>B. 用户同意给予客户端授权</p><p>C. 客户端得到授权后，向认证服务器进行申请令牌（token)</p><p>D. 认证服务器对客户端进行认证，验证正确后发放令牌</p><p>E. 客户端利用令牌向资源服务器申请获取资源</p><p>F. 资源服务器确认令牌正确后，同意向客户端开发资源</p><p>其中关键的步骤是B，用户如何给客户端进行授权</p><h3 id="0x03-客户端授权模式、"><a href="#0x03-客户端授权模式、" class="headerlink" title="0x03 客户端授权模式、"></a>0x03 客户端授权模式、</h3><p>OAuth2.0指定了四种授权方式</p><ul><li><p>授权码模式（authorization code)</p></li><li><p>简化模式（implicit）</p></li><li><p>密码模式（resource owner password credentials)</p></li><li><p>客户端模式（client credentials)</p><h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><p>授权码模式（authorization code)是功能最完整、流程最严密的授权模式。特点是通过客户端的后台服务器与“服务提供商”的认证服务器进行互动。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2014/bg2014051204.png" alt="授权码模式"> </p></li></ul><p>步骤如下：</p><p>A. 用户访问客户端，客户端将用户端导向认证服务器</p><p>B. 用户选择是否给予客户端授权</p><p>C. 假设用户给予授权，认证服务器将用户导向客户端事先指定的“重定向URL”(redirection URL)，同时附上一个授权码。</p><p>D. 客户端收到授权码，附上早先的”重定向URL“，向认证服务器申请令牌。此步骤对用户不可见。</p><p>E. 认证服务器核对了授权码和重定向URL，确认无误后，向客户端发送访问令牌（Access Token）和更新令牌（refresh token)。</p><p>以上步骤所需参数</p><p>A. 客户端申请认证的URL，包含以下参数：</p><ul><li>response_type：表示授权类型，必选项。值固定为”code”</li><li>client_id：表示客户端的ID，必选项</li><li>redirect_uri：表示重定向URL，可选项</li><li>scope：表示申请的权限范围，可选项</li><li>state：表示当前客户端的状态，可以指定任意值，认证服务器会原封不动的返回这个值</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      OAuth2.0是用于授权的行业标准协议，允许用户授权第三方移动应用访问他们储存在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容。
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS连接过程和中间人攻击</title>
    <link href="https://comosk.github.io/2020/02/28/HTTPS%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
    <id>https://comosk.github.io/2020/02/28/HTTPS%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</id>
    <published>2020-02-28T15:22:52.000Z</published>
    <updated>2020-02-28T15:24:14.556Z</updated>
    
    <content type="html"><![CDATA[<p>大致过程如下：</p><ol><li><p>https请求</p><p>客户端向服务端发送https请求；</p></li><li><p>生成公钥和私钥</p><p>服务端收到请求之后，生成公钥和私钥。</p></li><li><p>返回公钥</p><p>服务端将公钥返回给服务端。公钥里包含很多信息，比如证书的颁发机构、过期时间等</p></li><li><p>客户端验证公钥</p><p>客户端收到公钥之后，验证是否有效。验证证书的颁发机构、过期时间等。如果验证不通过则会抛出异常，显示证书存在问题。如果验证通过，则会生成一个随机值，作为客户端的密钥，然后用服务端的公钥进行加密。</p></li><li><p>发送客户端密钥</p><p>客户端用服务端的公钥加密密钥，然后发送给服务端</p></li><li><p>服务端接收密钥，对称加密内容</p><p>服务端收到经过加密的密钥，然后私钥将其进行解密，得到客户端的密钥，然后服务端将要传输的内容，用客户端得密钥进行对称加密。</p></li><li><p>加密传输</p><p>服务端将经过加密的内容传输给客户端</p></li><li><p>获取加密内容，解密</p><p>客户端获取加密内容后，利用之前生成的随机值作为密钥进行解密，获取到内容。</p></li></ol><p>中间人进行劫持攻击时，关键在于信任中间人的证书。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      HTTPS连接的过程详情……
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="基础知识" scheme="https://comosk.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>漏洞名称：任意文件上传</title>
    <link href="https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</id>
    <published>2020-02-28T15:20:37.000Z</published>
    <updated>2020-02-28T15:21:39.614Z</updated>
    
    <content type="html"><![CDATA[<p>严重性：高</p><p>要求：文件上传时应该验证文件的类型、文件头信息、大小</p><p>No 1. 漏洞危害</p><p>可以通过恶意脚本文件控制整个网站、甚至控制服务器。恶意文件又被称为WebShell,网页后门。可以查看服务器目录、服务器中的文件、执行系统命令等。</p><p>No  2. 检测是否存在JS绕过攻击</p><ul><li>使用浏览器的插件，删除检测文件后缀的JS检测代码，然后上传文件即可。【注：插件可选择Firebox]</li><li>首先先把文件后缀改成允许上传的，饶过JS的检测，再抓包，再把后缀名改成可执行文件的后缀名即可上传成功。【抓包工具可选择Burp suite】</li></ul><p>No 3. 检测是否存在文件后缀绕过攻击</p><ul><li>服务器代码限制了某些后缀名不允许上传，但是可以允许解析其他文件后缀的。检测httpd.conf的配置文件，查看解析的文件后缀。apache的解析顺序是从右往左解析，直到遇见能解析的文件后缀为止。</li></ul><p>No 4. 检测是否存在文件类型绕过攻击</p><ul><li>通过Burp suite抓取数据包，检测如果上传不同格式的文件时，文件属性是不同的，如果服务端是通过文件类型来判断文件类型的，那么有可能存在被绕过的可能。因为文件类型是通过客户端传递，可以随意修改的。【在PHP语言中存在着一种类似的文件上传漏洞，如果是利用getimagesize()函数来获取图片长、宽、高等信息，如果不是图片就上传不成功，可以将图片和Webshell合并成一个文件，可以使用命令 cat test.php webshell.php &gt; test.php 可以绕过限制】</li></ul><p>No 5. 检测是否存在文件截断绕过攻击</p><ul><li>截断条件：PHP版本小于5.3.4，PHP的magic_quotes_gpc为OFF状态</li><li>截断符 %00，文件上传时，会把截断后的内容放在上传后文件名的第一部分，然后将按时间生成的文件名作为上传文件名的第二部门。【例：如果参数为1.php%00.jpg,那么将会变成1.php，就成功上传了webshell脚本】</li></ul><p>No 6. 检测是否存在竞争条件攻击</p><ul><li>利用检测和删除文件中间的时间，进行生成一个webShell的脚本文件，完成webShell文件的上传。</li></ul><ol><li><p>上传时检查不严。</p><ul><li>利用断点上传工具，来应当对只在客户端进行过滤。</li><li>在服务器端进行黑名单检查时，忽略了大小写。</li><li>在服务器进行白名单检查时，忽略%00的截断符。例只允许上传jpg,就可以构造XXX.exe%00.jpg,在服务端就可以变成xxx.exe</li><li>上传成功后修改后缀名，修改文件后缀名处理不当</li><li>若使用插件时，插件上可能带有文件上传漏洞</li></ul></li><li><p>防范文件上传漏洞</p><ul><li>文件上传目录设置成不可执行</li><li>判断文件类型。结合MIME Type、后缀检测方式。选择白名单</li><li>使用随机数改写文件名和文件路径</li><li>单独设置文件服务器的域名</li></ul><p>防御</p><ul><li>严格检查文件名和文件路径</li><li>服务端使用白名单进行过滤，然后截断符进行检测，HTTP的Content-type进行检测，同时也检测文件上传的大小</li><li>对上传的文件进行重命名。</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      可以通过恶意脚本文件控制整个网站、甚至控制服务器。恶意文件又被称为WebShell,网页后门。可以查看服务器目录、服务器中的文件、执行系统命令等。
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="任意文件上传/下载" scheme="https://comosk.github.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>漏洞名称：任意文件下载/读取</title>
    <link href="https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD-%E8%AF%BB%E5%8F%96/"/>
    <id>https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD-%E8%AF%BB%E5%8F%96/</id>
    <published>2020-02-28T15:18:48.000Z</published>
    <updated>2020-02-28T15:20:12.166Z</updated>
    
    <content type="html"><![CDATA[<p>严重性：High</p><p>漏洞类型：任意文件上传/下载漏洞</p><p>安全要求：文件下载应该验证文件的类型、文件头信息、大小、权限</p><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>某些网站由于业务需求，往往需要提供文件查看或文件下载功能，但是如果对用户查看或下载的文件不做限制，则恶意用户就能查看或下载任意敏感文件。即任意文件下载/读取漏洞。</p><p><strong>引起原因：</strong></p><ul><li>存在读文件的函数</li><li>读取文件的路径用户可控且未校验或校验不严</li><li>输出了文件内容</li></ul><h3 id="0x01-漏洞危害"><a href="#0x01-漏洞危害" class="headerlink" title="0x01 漏洞危害"></a>0x01 漏洞危害</h3><p>下载服务器任意文件，如脚本代码、服务及系统配置文件等，可以得到进一步代码审计，得到更多的可利用漏洞。</p><p><a href="https://shuimugan.com/bug/view?bug_no=62787" target="_blank" rel="noopener">wooyun文件任意下载实例</a></p><h3 id="0x02-任意文件读取"><a href="#0x02-任意文件读取" class="headerlink" title="0x02 任意文件读取"></a>0x02 任意文件读取</h3><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $filename = <span class="string">"test.txt"</span>;</span><br><span class="line">    readfile($filename);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $filename = <span class="string">"test.txt"</span>;</span><br><span class="line"></span><br><span class="line">    $fp = fopen($filename,<span class="string">"r"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">    $data = fread($fp,filesize($filename));</span><br><span class="line">    fclose($fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> $data;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $filename = <span class="string">"test.txt"</span>;</span><br><span class="line">    <span class="keyword">echo</span> file_get_contents($filename);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="0x03-任意文件下载"><a href="#0x03-任意文件下载" class="headerlink" title="0x03 任意文件下载"></a>0x03 任意文件下载</h3><p>直接下载：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.xx.com/a.zip"</span>&gt;</span>Download<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>header()下载</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $filename = <span class="string">"uploads/201607141437284653.jpg"</span>;</span><br><span class="line"></span><br><span class="line">    header(<span class="string">'Content-Type: imgage/jpeg'</span>);</span><br><span class="line">    header(<span class="string">'Content-Disposition: attachment; filename='</span>.$filename);</span><br><span class="line">    header(<span class="string">'Content-Lengh: '</span>.filesize($filename));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="0x04-利用代码"><a href="#0x04-利用代码" class="headerlink" title="0x04 利用代码"></a>0x04 利用代码</h3><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readfile.php?file=/etc/passwd</span><br><span class="line">readfile.php?file=../../../../../../../../etc/passwd</span><br><span class="line">readfile.php?file=../../../../../../../../etc/passwd%<span class="number">00</span></span><br></pre></td></tr></tbody></table></figure><p><strong>Google search</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inurl:<span class="string">"readfile.php?file="</span></span><br><span class="line">inurl:<span class="string">"read.php?filename="</span></span><br><span class="line">inurl:<span class="string">"download.php?file="</span></span><br><span class="line">inurl:<span class="string">"down.php?file="</span></span><br><span class="line">等等...</span><br></pre></td></tr></tbody></table></figure><h3 id="0x05-漏洞挖掘"><a href="#0x05-漏洞挖掘" class="headerlink" title="0x05 漏洞挖掘"></a>0x05 漏洞挖掘</h3><p>利用Google hacking或web漏洞扫描器</p><p>链接形式上：</p><ul><li>readfile.php?file=***.txt</li><li>download.php?file=***.rar</li></ul><p>从参数名看：</p><ul><li>&amp;RealPath=</li><li>&amp;FilePath=</li><li>&amp;filepath=</li><li>&amp;Path=</li><li>&amp;path</li><li>&amp;inputFile=</li><li>&amp;url=</li><li>&amp;urls=</li><li>&amp;Lang=</li><li>&amp;dis=</li><li>&amp;data=</li><li>&amp;readfile=</li><li>&amp;filep=</li><li>&amp;src=</li><li>&amp;menu=</li><li>META-INF</li><li>WEB-INF</li></ul><h3 id="0x06-常见敏感文件"><a href="#0x06-常见敏感文件" class="headerlink" title="0x06 常见敏感文件"></a>0x06 常见敏感文件</h3><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Windows：</span><br><span class="line">   C:\boot.ini  <span class="comment">//查看系统版本</span></span><br><span class="line">   C:\Windows\System32\inetsrv\MetaBase.xml  <span class="comment">//IIS配置文件</span></span><br><span class="line">   C:\Windows\repair\sam  <span class="comment">//存储系统初次安装的密码</span></span><br><span class="line">   C:\Program Files\mysql\my.ini  <span class="comment">//Mysql配置</span></span><br><span class="line">   C:\Program Files\mysql\<span class="keyword">data</span>\mysql\user.MYD  <span class="comment">//Mysql root</span></span><br><span class="line">   C:\Windows\php.ini  <span class="comment">//php配置信息</span></span><br><span class="line">   C:\Windows\my.ini  <span class="comment">//Mysql配置信息</span></span><br><span class="line">   ...</span><br><span class="line">Linux：</span><br><span class="line">   /root/.ssh/authorized_keys</span><br><span class="line">   /root/.ssh/id_rsa</span><br><span class="line">   /root/.ssh/id_ras.keystore</span><br><span class="line">   /root/.ssh/known_hosts</span><br><span class="line">   /etc/passwd</span><br><span class="line">   /etc/shadow</span><br><span class="line">   /etc/my.cnf</span><br><span class="line">   /etc/httpd/conf/httpd.conf</span><br><span class="line">   /root/.bash_history</span><br><span class="line">   /root/.mysql_history</span><br><span class="line">   /proc/self/fd/fd[<span class="number">0</span>-<span class="number">9</span>]*(文件标识符)</span><br><span class="line">   /proc/mounts</span><br><span class="line">   /porc/config.gz</span><br></pre></td></tr></tbody></table></figure><h3 id="0x07-漏洞验证"><a href="#0x07-漏洞验证" class="headerlink" title="0x07 漏洞验证"></a>0x07 漏洞验证</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">• index.php?f=../../../../../../etc/passwd </span><br><span class="line">• index.php?f=../index.php </span><br><span class="line">• index.php?f=ﬁle:<span class="comment">///etc/passwd</span></span><br><span class="line">注：当参数f的参数值为php文件时，若是文件被解析则是文件包含漏洞，</span><br><span class="line">    若显示源码或提示下载则是文件查看与下载漏洞</span><br></pre></td></tr></tbody></table></figure><h3 id="0x08-安全建议"><a href="#0x08-安全建议" class="headerlink" title="0x08 安全建议"></a>0x08 安全建议</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 过滤.(点)，使用户在<span class="selector-tag">url</span>中不能回溯上级目录</span><br><span class="line">* 正则严格判断用户输入参数的格式</span><br><span class="line">* <span class="selector-tag">php</span><span class="selector-class">.ini</span>配置<span class="selector-tag">open_basedir</span>限定文件访问范围</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      某些网站由于业务需求，往往需要提供文件查看或文件下载功能，但是如果对用户查看或下载的文件不做限制，则恶意用户就能查看或下载任意敏感文件。即任意文件下载/读取漏洞。
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="任意文件上传/下载" scheme="https://comosk.github.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>漏洞名称：任意文件删除</title>
    <link href="https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4/"/>
    <id>https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4/</id>
    <published>2020-02-28T15:16:06.000Z</published>
    <updated>2020-02-28T15:17:29.074Z</updated>
    
    <content type="html"><![CDATA[<p>严重性：High</p><p>漏洞类型：任意文件上传/下载</p><p>安全要求：文件删除应该验证文件的类型、权限</p><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>Web项目中，设计文件删除操作的函数，如果文件名可控，将可能存在任意文件删除漏洞，该漏洞可能让攻击者随意删除服务器上的任意文件。</p><h3 id="0x01-测试方法"><a href="#0x01-测试方法" class="headerlink" title="0x01 测试方法"></a>0x01 测试方法</h3><p>任意删除文件漏洞常存在于删除头像、文章附件、CMS管理插件、模块、数据库备份删除的地方和文件重写的地方，通常来说文件的删除需要严格控制用户的权限和资源所有对象，任意文件删除主要再鱼寻找类似PHP中的unlink()函数或者文件覆盖的一些函数。</p><h3 id="0x02-示例演示"><a href="#0x02-示例演示" class="headerlink" title="0x02 示例演示"></a>0x02 示例演示</h3><p><strong>示例为Discuz&lt;=3.4 任意文件删除漏洞</strong></p><p> <img src="https://upload-images.jianshu.io/upload_images/7119304-abb92c6834681bb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"> </p><ol><li><p>利用Burp suite进行抓包，得到formhash，并在brithprovince中改成问哦们要删除的文件路径（../../../test.txt），此时参数为文件站点存在的文件，就是要删除的文件。</p><p><img src="https://upload-images.jianshu.io/upload_images/7119304-6bb7d5d7824d2b18.png" alt="img"></p></li></ol><p> <img src="https://upload-images.jianshu.io/upload_images/7119304-635847de4be3f9fd.png" alt="img"> </p><ol><li><p>在本地创建执行更改服务器的表单，同时构造请求去执行删除的文件。请求home？php?mod=spacecp&amp;ac=profile&amp;op=base POST birthprovince=../../../test.txt&amp;profilesublimit=1&amp;formhash=2fce4b73</p><p>其中formhash为用户hash</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Upload<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://127.0.0.1:8080/code_audit/Discuz_X3.3_SC_UTF8/upload/home.php?mod=spacecp&amp;ac=profile&amp;op=base method="</span><span class="attr">POST</span>" <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"birthprovince"</span> <span class="attr">id</span>=<span class="string">"file"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"formhash"</span> <span class="attr">value</span>=<span class="string">"a7ccdf77"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"profilesubmit"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7119304-214cf6322bae7363.png" alt="img"> </p></li></ol><h3 id="0x03-示例分析"><a href="#0x03-示例分析" class="headerlink" title="0x03 示例分析"></a>0x03 示例分析</h3><p>漏洞出现在/upload/source/include/spacecp/spacecp_profile.php<img src="https://upload-images.jianshu.io/upload_images/7119304-14e559ceb8352cbc.png" alt="img"> </p><p>第182、183行有两个unlink()函数是可以删除文件，但是前提条件是需要formtype=file才可以</p><p> <img src="https://upload-images.jianshu.io/upload_images/7119304-c4432975c08878b9.png" alt="img"> </p><p>由于不是不是file所以继续往下看</p><p> <img src="https://upload-images.jianshu.io/upload_images/7119304-123a3e4ce841c30f.png" alt="img"> </p><p>第229行存在unlink()函数吗，并且无任何判断，即程序运行到此处就可以删除文件</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@unlink</span>(getglobal('setting/attachdir').'./profile/'.$space[$key]);</span><br></pre></td></tr></tbody></table></figure><p>回溯发现$space[$key]</p><p> <img src="https://upload-images.jianshu.io/upload_images/7119304-a170e7cf10ffbcff.png" alt="img"> </p><p>此处就是用户的个人设置，选择brith[rovince]，更改成要删除的文件就ok了，然后实现文件上传的表单，就可以删除文件。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      Web项目中，设计文件删除操作的函数，如果文件名可控，将可能存在任意文件删除漏洞，该漏洞可能让攻击者随意删除服务器上的任意文件。
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="任意文件上传/下载" scheme="https://comosk.github.io/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>漏洞名称：中间件信息泄露</title>
    <link href="https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    <id>https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/</id>
    <published>2020-02-28T15:14:16.000Z</published>
    <updated>2020-02-28T15:15:21.789Z</updated>
    
    <content type="html"><![CDATA[<p>严重性：Low</p><p>漏洞类型：敏感信息泄露</p><p>安全要求：查看前端返回的信息中是否包含中间件版本信息</p><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>​        什么是中间件版本信息泄露？通常在HTTP报文的响应头中存在的标志、版本号等信息均属于中间件的版本信息泄露。</p><p>​        特点是：通常出现在默认安装好的Web中间件上，大部分管理员不会修改这个标志。</p><p>​        原理是：各大Web服务中间件为了打造品牌效应而在HTTP响应头中添加了标志信息、版本号。</p><h3 id="0x01-常见场景"><a href="#0x01-常见场景" class="headerlink" title="0x01 常见场景"></a>0x01 常见场景</h3><ul><li>Tomcat</li><li>Nginx</li><li>Apache</li><li>IIS</li><li>……均有此类现象</li></ul><h3 id="0x02-测试方案"><a href="#0x02-测试方案" class="headerlink" title="0x02 测试方案"></a>0x02 测试方案</h3><p>使用CURL发送OPTIONS、GET、POST、HEAD等请求，查看响应头中的Server行</p><p>命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I -X GET http://payloads.online</span><br></pre></td></tr></tbody></table></figure><h3 id="0x03-修复方案"><a href="#0x03-修复方案" class="headerlink" title="0x03 修复方案"></a>0x03 修复方案</h3><ul><li><p>Apache</p><p>将以下配置加入<code>conf/httpd.conf</code></p></li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerTokens Prod</span><br><span class="line"></span><br><span class="line">ServerSignaturre Off</span><br></pre></td></tr></tbody></table></figure><ul><li><p>PHP</p><p>修改<code>php.ini</code>，将<code>expose_php On</code>改为<code>expose_php Off</code></p></li><li><p>IIS</p><p>找到<code>HTTP响应头</code>设置响应报文内容，可以将<code>ASP.NET</code>随意更改，甚至删除</p></li><li><p>Nginx</p><p>将以下配置加入<code>conf/nginx.conf</code></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_tokens off;</span><br></pre></td></tr></tbody></table></figure></li><li><p>Tomcat</p><p>到apache-tomcat安装目录下的lib子文件夹，找到catalina.jar这包，并进行解解压 </p><p>修改： <code>lib\catalina.zip\org\apache\catalina\util\ServerInfo.properties</code> </p></li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.info=X</span><br><span class="line">server.number=5.5</span><br><span class="line">server.built=Dec 1 2015 22:30:46 UTC</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      什么是中间件版本信息泄露？通常在HTTP报文的响应头中存在的标志、版本号等信息均属于中间件的版本信息泄露。
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="敏感信息泄露" scheme="https://comosk.github.io/tags/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>漏洞名称：文件遍历</title>
    <link href="https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E6%96%87%E4%BB%B6%E9%81%8D%E5%8E%86/"/>
    <id>https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E6%96%87%E4%BB%B6%E9%81%8D%E5%8E%86/</id>
    <published>2020-02-28T15:12:46.000Z</published>
    <updated>2020-02-28T15:13:51.392Z</updated>
    
    <content type="html"><![CDATA[<p>严重性：Medium</p><p>漏洞类型：敏感信息泄露</p><p>安全要求：使用Web扫描器进行检测，参数导致的系统文件任意访问。</p><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>文件遍历可以浏览Web目录下的文件列表，可能会泄露重要文件。文件遍历的利用方法是通过路径直接访问资源，文件遍历的危害比目录遍历的危害大，文件遍历不仅可以泄露网站的结构，攻击者还可以直接获取网站文件的内容。攻击者可以获得很多机密的文件，比如配置文件、比如/etc/passwd，如脚本代码、可以得到代码进一步代码审计，得到更多可以利用的漏洞。</p><h3 id="0x01-检测方法"><a href="#0x01-检测方法" class="headerlink" title="0x01 检测方法"></a>0x01 检测方法</h3><ul><li>通过Web漏洞扫描工具对网站实施扫描可能发现任意文件读取漏洞，发送一系列”../“字符来遍历高层目录，并且尝试找到系统的配置文件或者系统中存在的敏感文件。</li><li>通过判断网站语言，并根据url中部分提供的参数，进行构造相关的路径信息，如收集到网站中间件版本为Apache，则可以通过构造../../../WEB-INF/web.xml等，然后查看其是否可以被读取出来。</li><li>对于有WAF过滤 ../，可以构造 /.%252e/.%252e/.%252e/，%25对应的是%，%2e对应的是.，所以.%252e/对应的是 ../</li></ul><h3 id="0x02-常见路径"><a href="#0x02-常见路径" class="headerlink" title="0x02 常见路径"></a>0x02 常见路径</h3><figure class="highlight dts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">Windows：</span><br><span class="line"><span class="symbol">   C:</span>\boot.ini  <span class="comment">//查看系统版本</span></span><br><span class="line"><span class="symbol">   C:</span>\Windows\System32\inetsrv\MetaBase.xml  <span class="comment">//IIS配置文件</span></span><br><span class="line"><span class="symbol">   C:</span>\Windows\repair\sam  <span class="comment">//存储系统初次安装的密码</span></span><br><span class="line"><span class="symbol">   C:</span>\Program Files\mysql\my.ini  <span class="comment">//Mysql配置</span></span><br><span class="line"><span class="symbol">   C:</span>\Program Files\mysql\data\mysql\user.MYD  <span class="comment">//Mysql root</span></span><br><span class="line"><span class="symbol">   C:</span>\Windows\php.ini  <span class="comment">//php配置信息</span></span><br><span class="line"><span class="symbol">   C:</span>\Windows\my.ini  <span class="comment">//Mysql配置信息</span></span><br><span class="line">   ...</span><br><span class="line">Linux：</span><br><span class="line">   <span class="meta-keyword">/etc/</span>passwd                  <span class="meta">#查看用户文件</span></span><br><span class="line">   <span class="meta-keyword">/etc/</span>shadow                  <span class="meta">#查看密码文件</span></span><br><span class="line">   <span class="meta-keyword">/etc/</span>my.cnf </span><br><span class="line">   <span class="meta-keyword">/etc/</span>httpd<span class="meta-keyword">/conf/</span>httpd.conf   <span class="meta">#查看apache的配置文件</span></span><br><span class="line">   <span class="meta-keyword">/root/</span>.bash_history          <span class="meta">#查看历史命令</span></span><br><span class="line">   <span class="meta-keyword">/root/</span>.mysql_history         <span class="meta">#mysql历史命令记录文件</span></span><br><span class="line">   <span class="meta-keyword">/var/</span>lib<span class="meta-keyword">/mlocate/</span>mlocate.db  <span class="meta">#本地所有文件信息</span></span><br><span class="line">   <span class="meta-keyword">/etc/</span>ssh/sshd_config         <span class="meta">#ssh配置文件，如果对外开放可看到端口</span></span><br><span class="line">   <span class="meta-keyword">/proc/</span>self<span class="meta-keyword">/fd/</span>fd[<span class="number">0</span><span class="number">-9</span>]*(文件标识符)</span><br><span class="line">   <span class="meta-keyword">/proc/</span>mounts</span><br><span class="line">   <span class="meta-keyword">/porc/</span>config.gz</span><br><span class="line">   <span class="meta-keyword">/root/</span>.ssh/authorized_keys                </span><br><span class="line">   <span class="meta-keyword">/root/</span>.ssh/id_rsa  </span><br><span class="line">   <span class="meta-keyword">/root/</span>.ssh/id_ras.keystore</span><br><span class="line">   <span class="meta-keyword">/root/</span>.ssh/known_hosts</span><br><span class="line">程序的配置文件</span><br><span class="line">apache：</span><br><span class="line">    <span class="meta-keyword">/etc/</span>httpd<span class="meta-keyword">/conf/</span>httpd.conf</span><br><span class="line">    <span class="meta-keyword">/etc/</span>apache2/httpd.conf</span><br><span class="line">    <span class="meta-keyword">/etc/</span>apache2/apache2.conf</span><br><span class="line">nginx：</span><br><span class="line">    <span class="meta-keyword">/etc/</span>nginx/nginx.conf</span><br><span class="line">    <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/nginx/</span>conf/nginx.conf</span><br><span class="line">    <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/etc/</span>nginx/nginx.conf</span><br><span class="line">redis：</span><br><span class="line">    <span class="meta-keyword">/etc/</span>redis.conf</span><br><span class="line">index.php?f=../../../../../..<span class="meta-keyword">/etc/</span>passwd </span><br><span class="line">Windows：</span><br><span class="line"><span class="symbol">   C:</span>\boot.ini  <span class="comment">//查看系统版本</span></span><br><span class="line"><span class="symbol">   C:</span>\Windows\System32\inetsrv\MetaBase.xml  <span class="comment">//IIS配置文件</span></span><br><span class="line"><span class="symbol">   C:</span>\Windows\repair\sam  <span class="comment">//存储系统初次安装的密码</span></span><br><span class="line"><span class="symbol">   C:</span>\Program Files\mysql\my.ini  <span class="comment">//Mysql配置</span></span><br><span class="line"><span class="symbol">   C:</span>\Program Files\mysql\data\mysql\user.MYD  <span class="comment">//Mysql root</span></span><br><span class="line"><span class="symbol">   C:</span>\Windows\php.ini  <span class="comment">//php配置信息</span></span><br><span class="line"><span class="symbol">   C:</span>\Windows\my.ini  <span class="comment">//Mysql配置信息</span></span><br><span class="line">   ...</span><br><span class="line">Linux：</span><br><span class="line">   <span class="meta-keyword">/etc/</span>passwd                  <span class="meta">#查看用户文件</span></span><br><span class="line">   <span class="meta-keyword">/etc/</span>shadow                  <span class="meta">#查看密码文件</span></span><br><span class="line">   <span class="meta-keyword">/etc/</span>my.cnf </span><br><span class="line">   <span class="meta-keyword">/etc/</span>httpd<span class="meta-keyword">/conf/</span>httpd.conf   <span class="meta">#查看apache的配置文件</span></span><br><span class="line">   <span class="meta-keyword">/root/</span>.bash_history          <span class="meta">#查看历史命令</span></span><br><span class="line">   <span class="meta-keyword">/root/</span>.mysql_history         <span class="meta">#mysql历史命令记录文件</span></span><br><span class="line">   <span class="meta-keyword">/var/</span>lib<span class="meta-keyword">/mlocate/</span>mlocate.db  <span class="meta">#本地所有文件信息</span></span><br><span class="line">   <span class="meta-keyword">/etc/</span>ssh/sshd_config         <span class="meta">#ssh配置文件，如果对外开放可看到端口</span></span><br><span class="line">   <span class="meta-keyword">/proc/</span>self<span class="meta-keyword">/fd/</span>fd[<span class="number">0</span><span class="number">-9</span>]*(文件标识符)</span><br><span class="line">   <span class="meta-keyword">/proc/</span>mounts</span><br><span class="line">   <span class="meta-keyword">/porc/</span>config.gz</span><br><span class="line">   <span class="meta-keyword">/root/</span>.ssh/authorized_keys                </span><br><span class="line">   <span class="meta-keyword">/root/</span>.ssh/id_rsa  </span><br><span class="line">   <span class="meta-keyword">/root/</span>.ssh/id_ras.keystore</span><br><span class="line">   <span class="meta-keyword">/root/</span>.ssh/known_hosts</span><br><span class="line"> </span><br><span class="line">程序的配置文件</span><br><span class="line">apache：</span><br><span class="line">    <span class="meta-keyword">/etc/</span>httpd<span class="meta-keyword">/conf/</span>httpd.conf</span><br><span class="line">    <span class="meta-keyword">/etc/</span>apache2/httpd.conf</span><br><span class="line">    <span class="meta-keyword">/etc/</span>apache2/apache2.conf</span><br><span class="line"> </span><br><span class="line">nginx：</span><br><span class="line">    <span class="meta-keyword">/etc/</span>nginx/nginx.conf</span><br><span class="line">    <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/nginx/</span>conf/nginx.conf</span><br><span class="line">    <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/etc/</span>nginx/nginx.conf</span><br><span class="line"> </span><br><span class="line">redis：</span><br><span class="line">    <span class="meta-keyword">/etc/</span>redis.conf</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">index.php?f=../../../../../..<span class="meta-keyword">/etc/</span>passwd</span><br></pre></td></tr></tbody></table></figure><h3 id="0x03-文件遍历的危害"><a href="#0x03-文件遍历的危害" class="headerlink" title="0x03 文件遍历的危害"></a>0x03 文件遍历的危害</h3><ul><li>下载源代码审计</li><li>数据库备份</li><li>信息收集</li><li>中间件</li></ul><h3 id="0x04-安全建议"><a href="#0x04-安全建议" class="headerlink" title="0x04 安全建议"></a>0x04 安全建议</h3><ul><li>净化数据：对用户传送过来的文件名参数统一进行编码，对文件类型进行白名单控制，对包含恶意字符或者空字符的参数进行拒绝。</li><li>文件放在web无法直接访问的目录下</li></ul><h3 id="0x05-漏洞实例"><a href="#0x05-漏洞实例" class="headerlink" title="0x05 漏洞实例"></a>0x05 漏洞实例</h3><p> <a href="https://shuimugan.com/bug/view?bug_no=105069" target="_blank" rel="noopener">文件遍历导致敏感信息泄露</a> </p><p><a href="https://www.secpulse.com/archives/24602.html" target="_blank" rel="noopener">途牛文件遍历导致敏感信息泄露</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      使用Web扫描器进行检测，参数导致的系统文件任意访问。
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="敏感信息泄露" scheme="https://comosk.github.io/tags/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>漏洞名称：目录遍历</title>
    <link href="https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/"/>
    <id>https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/</id>
    <published>2020-02-28T15:11:07.000Z</published>
    <updated>2020-02-28T15:12:20.584Z</updated>
    
    <content type="html"><![CDATA[<p>严重性：Medium</p><p>漏洞类型：敏感信息泄露</p><p>安全要求：使用Web扫描器进行检测，设置不当导致的可向不用能访问的目录遍历</p><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>当客户端访问一个目录时,Web服务中间件将默认寻找一个<code>index list</code>中的文件，若文件不存在，则会列出当前目录下所有文件或返回403状态码，而列出目录下所有文件的行为称为目录遍历。</p><p>原因是中间件配置不得当</p><h3 id="0x01-常见场景"><a href="#0x01-常见场景" class="headerlink" title="0x01 常见场景"></a>0x01 常见场景</h3><ul><li>Tomcat</li><li>Nginx</li><li>Apache</li><li>IIS</li><li>……等服务器</li></ul><h3 id="0x02-测试方法"><a href="#0x02-测试方法" class="headerlink" title="0x02 测试方法"></a>0x02 测试方法</h3><p>利用dirb扫描一些存在的目录，再用浏览器访问已存在的目录，查看是否能够列出目录下的文件</p><p>命令：<code>dirb http://target</code></p><p> <img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-04-27/0x02.gif" alt="0x02"> </p><h3 id="0x03-修复方案"><a href="#0x03-修复方案" class="headerlink" title="0x03 修复方案"></a>0x03 修复方案</h3><ul><li><p><strong>Apache</strong> </p><p>修改站点目录对应的配置文件</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Directory</span>/&gt;</span></span><br><span class="line">Options +Indexes +FollowSymLinks # 将 “+” 与Indexes去掉即可列出目录索引</span><br><span class="line">AllowOverride All</span><br><span class="line">Order allow,deny</span><br><span class="line">Allow from all</span><br><span class="line">Require all granted</span><br><span class="line"><span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul><p>修改后</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Directory</span>/&gt;</span></span><br><span class="line">Options FollowSymLinks </span><br><span class="line">AllowOverride All</span><br><span class="line">Order allow,deny</span><br><span class="line">Allow from all</span><br><span class="line">Require all granted</span><br><span class="line"><span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>Tomcat</strong></p><p>修改conf/web.xml配置文件</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span><span class="comment">&lt;!-- 将true改成false --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>修改后</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>Nginx</strong></p><p>修改conf/nginx.conf配置文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / {</span><br><span class="line">index index.html index.htm index.php 1.php;</span><br><span class="line">autoindex on;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>修改后</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / {</span><br><span class="line">index index.html index.htm index.php 1.php;</span><br><span class="line">autoindex off;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>IIS</p><p>设置“目录浏览”权限<img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2017-11-15/0x08.png" alt="设置目录索引"> </p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      使用Web扫描器进行检测，设置不当导致的可向不用能访问的目录遍历
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="敏感信息泄露" scheme="https://comosk.github.io/tags/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>漏洞名称：后台管理界面外网泄露</title>
    <link href="https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%A4%96%E7%BD%91%E6%B3%84%E9%9C%B2/"/>
    <id>https://comosk.github.io/2020/02/28/%E6%BC%8F%E6%B4%9E%E5%90%8D%E7%A7%B0%EF%BC%9A%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E5%A4%96%E7%BD%91%E6%B3%84%E9%9C%B2/</id>
    <published>2020-02-28T15:09:08.000Z</published>
    <updated>2020-02-28T15:10:26.289Z</updated>
    
    <content type="html"><![CDATA[<p>严重性：Medium</p><p>安全要求：应保证应用系统的管理安全，后台管理界面（包括但不限于：可操作管理多个账号，具有账号权限功能增删改权限的用户界面；可发布公告等内容管理的用户界面；可查询应用日志系统日志账户；可更改应用系统界面内容配置账户）不能向互联网暴露。</p><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>网站后台管理系统主要是用于对网站前台的信息管理，如文字、图片、影音和其他日常使用文件的发布、更新、删除等操作，同时也包括会员信息、订单信息、访客信息的统计和管理等相关操作。简单来说就是对网站数据库和文件的快速操作和系统管理，方便前台内容的更新和管理。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      应保证应用系统的管理安全，后台管理界面（包括但不限于：可操作管理多个账号，具有账号权……
    
    </summary>
    
    
      <category term="Web安全" scheme="https://comosk.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="敏感信息泄露" scheme="https://comosk.github.io/tags/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
</feed>
